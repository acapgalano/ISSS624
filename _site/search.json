[
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html",
    "title": "In-class Exercise 5",
    "section": "",
    "text": "This is an In-class Exercise that focuses on geographically weighted logistic regression."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#loading-the-packages",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#loading-the-packages",
    "title": "In-class Exercise 5",
    "section": "Loading the Packages",
    "text": "Loading the Packages\n\n\nPress to toggle code\npacman::p_load(sf, tidyverse, funModeling, blorr, corrplot,\n               ggpubr, spdep, GWmodel, tmap, skimr, caret)\n\n\n\n\n\n\n\n\nüéÆ LEVEL UP!\n\n\n\nNEW PACKAGE UNLOCKED:\n\nblorr - contains tools for building and validating binary logistic regression models\nskimr - provides summary statistics\ncaret - usually used for machine learning; used for error metrics in this exercise"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#importing-the-data",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#importing-the-data",
    "title": "In-class Exercise 5",
    "section": "Importing the Data",
    "text": "Importing the Data\n\nImporting the analytical data\nUsing read_rds() we import the analytical data into the R environment.\n\n\nPress to toggle code\nosun <- read_rds(\"data/Osun.rds\")\n\nosun_wp_sf <- read_rds(\"data/Osun_wp_sf.rds\")\n\n\nWe then produce the following simple feature objects:\n\n`‚Äôosun‚Äô (‚ÄôOsun.rds‚Äô) - the polygon data containing the boundaries of Osun\n‚Äòosun_wp_sf‚Äô (‚ÄòOsun_wp_sf.rds‚Äô ) - the data of water points found in Osun"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#distribution-of-status",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#distribution-of-status",
    "title": "In-class Exercise 5",
    "section": "Distribution of 'status'",
    "text": "Distribution of 'status'\n\n\nPress to toggle code\nosun_wp_sf %>% freq(input = 'status')\n\n\n\n\n\n  status frequency percentage cumulative_perc\n1   TRUE      2642       55.5            55.5\n2  FALSE      2118       44.5           100.0\n\n\nWe do this to check our dependent variable. Since later on we will be doing logistic regression, we need to make sure our data isn‚Äôt biased to one outcome."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#summary-statistics-with-skimr",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#summary-statistics-with-skimr",
    "title": "In-class Exercise 5",
    "section": "Summary Statistics with skimr",
    "text": "Summary Statistics with skimr\nThe function skim() provides a comprehensive summary of our variables as shown below.\n\n\nPress to toggle code\nosun_wp_sf %>% skim()\n\n\n\nData summary\n\n\nName\nPiped data\n\n\nNumber of rows\n4760\n\n\nNumber of columns\n75\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n47\n\n\nlogical\n5\n\n\nnumeric\n23\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nsource\n0\n1.00\n5\n44\n0\n2\n0\n\n\nreport_date\n0\n1.00\n22\n22\n0\n42\n0\n\n\nstatus_id\n0\n1.00\n2\n7\n0\n3\n0\n\n\nwater_source_clean\n0\n1.00\n8\n22\n0\n3\n0\n\n\nwater_source_category\n0\n1.00\n4\n6\n0\n2\n0\n\n\nwater_tech_clean\n24\n0.99\n9\n23\n0\n3\n0\n\n\nwater_tech_category\n24\n0.99\n9\n15\n0\n2\n0\n\n\nfacility_type\n0\n1.00\n8\n8\n0\n1\n0\n\n\nclean_country_name\n0\n1.00\n7\n7\n0\n1\n0\n\n\nclean_adm1\n0\n1.00\n3\n5\n0\n5\n0\n\n\nclean_adm2\n0\n1.00\n3\n14\n0\n35\n0\n\n\nclean_adm3\n4760\n0.00\nNA\nNA\n0\n0\n0\n\n\nclean_adm4\n4760\n0.00\nNA\nNA\n0\n0\n0\n\n\ninstaller\n4760\n0.00\nNA\nNA\n0\n0\n0\n\n\nmanagement_clean\n1573\n0.67\n5\n37\n0\n7\n0\n\n\nstatus_clean\n0\n1.00\n9\n32\n0\n7\n0\n\n\npay\n0\n1.00\n2\n39\n0\n7\n0\n\n\nfecal_coliform_presence\n4760\n0.00\nNA\nNA\n0\n0\n0\n\n\nsubjective_quality\n0\n1.00\n18\n20\n0\n4\n0\n\n\nactivity_id\n4757\n0.00\n36\n36\n0\n3\n0\n\n\nscheme_id\n4760\n0.00\nNA\nNA\n0\n0\n0\n\n\nwpdx_id\n0\n1.00\n12\n12\n0\n4760\n0\n\n\nnotes\n0\n1.00\n2\n96\n0\n3502\n0\n\n\norig_lnk\n4757\n0.00\n84\n84\n0\n1\n0\n\n\nphoto_lnk\n41\n0.99\n84\n84\n0\n4719\n0\n\n\ncountry_id\n0\n1.00\n2\n2\n0\n1\n0\n\n\ndata_lnk\n0\n1.00\n79\n96\n0\n2\n0\n\n\nwater_point_history\n0\n1.00\n142\n834\n0\n4750\n0\n\n\nclean_country_id\n0\n1.00\n3\n3\n0\n1\n0\n\n\ncountry_name\n0\n1.00\n7\n7\n0\n1\n0\n\n\nwater_source\n0\n1.00\n8\n30\n0\n4\n0\n\n\nwater_tech\n0\n1.00\n5\n37\n0\n20\n0\n\n\nadm2\n0\n1.00\n3\n14\n0\n33\n0\n\n\nadm3\n4760\n0.00\nNA\nNA\n0\n0\n0\n\n\nmanagement\n1573\n0.67\n5\n47\n0\n7\n0\n\n\nadm1\n0\n1.00\n4\n5\n0\n4\n0\n\n\nNew Georeferenced Column\n0\n1.00\n16\n35\n0\n4760\n0\n\n\nlat_lon_deg\n0\n1.00\n13\n32\n0\n4760\n0\n\n\npublic_data_source\n0\n1.00\n84\n102\n0\n2\n0\n\n\nconverted\n0\n1.00\n53\n53\n0\n1\n0\n\n\ncreated_timestamp\n0\n1.00\n22\n22\n0\n2\n0\n\n\nupdated_timestamp\n0\n1.00\n22\n22\n0\n2\n0\n\n\nGeometry\n0\n1.00\n33\n37\n0\n4760\n0\n\n\nADM2_EN\n0\n1.00\n3\n14\n0\n30\n0\n\n\nADM2_PCODE\n0\n1.00\n8\n8\n0\n30\n0\n\n\nADM1_EN\n0\n1.00\n4\n4\n0\n1\n0\n\n\nADM1_PCODE\n0\n1.00\n5\n5\n0\n1\n0\n\n\n\nVariable type: logical\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\ncount\n\n\n\n\nrehab_year\n4760\n0\nNaN\n:\n\n\nrehabilitator\n4760\n0\nNaN\n:\n\n\nis_urban\n0\n1\n0.39\nFAL: 2884, TRU: 1876\n\n\nlatest_record\n0\n1\n1.00\nTRU: 4760\n\n\nstatus\n0\n1\n0.56\nTRU: 2642, FAL: 2118\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nrow_id\n0\n1.00\n68550.48\n10216.94\n49601.00\n66874.75\n68244.50\n69562.25\n471319.00\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\nlat_deg\n0\n1.00\n7.68\n0.22\n7.06\n7.51\n7.71\n7.88\n8.06\n‚ñÅ‚ñÇ‚ñá‚ñá‚ñá\n\n\nlon_deg\n0\n1.00\n4.54\n0.21\n4.08\n4.36\n4.56\n4.71\n5.06\n‚ñÉ‚ñÜ‚ñá‚ñá‚ñÇ\n\n\ninstall_year\n1144\n0.76\n2008.63\n6.04\n1917.00\n2006.00\n2010.00\n2013.00\n2015.00\n‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñá\n\n\nfecal_coliform_value\n4760\n0.00\nNaN\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\ndistance_to_primary_road\n0\n1.00\n5021.53\n5648.34\n0.01\n719.36\n2972.78\n7314.73\n26909.86\n‚ñá‚ñÇ‚ñÅ‚ñÅ‚ñÅ\n\n\ndistance_to_secondary_road\n0\n1.00\n3750.47\n3938.63\n0.15\n460.90\n2554.25\n5791.94\n19559.48\n‚ñá‚ñÉ‚ñÅ‚ñÅ‚ñÅ\n\n\ndistance_to_tertiary_road\n0\n1.00\n1259.28\n1680.04\n0.02\n121.25\n521.77\n1834.42\n10966.27\n‚ñá‚ñÇ‚ñÅ‚ñÅ‚ñÅ\n\n\ndistance_to_city\n0\n1.00\n16663.99\n10960.82\n53.05\n7930.75\n15030.41\n24255.75\n47934.34\n‚ñá‚ñá‚ñÜ‚ñÉ‚ñÅ\n\n\ndistance_to_town\n0\n1.00\n16726.59\n12452.65\n30.00\n6876.92\n12204.53\n27739.46\n44020.64\n‚ñá‚ñÖ‚ñÉ‚ñÉ‚ñÇ\n\n\nrehab_priority\n2654\n0.44\n489.33\n1658.81\n0.00\n7.00\n91.50\n376.25\n29697.00\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\nwater_point_population\n4\n1.00\n513.58\n1458.92\n0.00\n14.00\n119.00\n433.25\n29697.00\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\nlocal_population_1km\n4\n1.00\n2727.16\n4189.46\n0.00\n176.00\n1032.00\n3717.00\n36118.00\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\ncrucialness_score\n798\n0.83\n0.26\n0.28\n0.00\n0.07\n0.15\n0.35\n1.00\n‚ñá‚ñÉ‚ñÅ‚ñÅ‚ñÅ\n\n\npressure_score\n798\n0.83\n1.46\n4.16\n0.00\n0.12\n0.41\n1.24\n93.69\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\nusage_capacity\n0\n1.00\n560.74\n338.46\n300.00\n300.00\n300.00\n1000.00\n1000.00\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÖ\n\n\ndays_since_report\n0\n1.00\n2692.69\n41.92\n1483.00\n2688.00\n2693.00\n2700.00\n4645.00\n‚ñÅ‚ñá‚ñÅ‚ñÅ‚ñÅ\n\n\nstaleness_score\n0\n1.00\n42.80\n0.58\n23.13\n42.70\n42.79\n42.86\n62.66\n‚ñÅ‚ñÅ‚ñá‚ñÅ‚ñÅ\n\n\nlocation_id\n0\n1.00\n235865.49\n6657.60\n23741.00\n230638.75\n236199.50\n240061.25\n267454.00\n‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñá\n\n\ncluster_size\n0\n1.00\n1.05\n0.25\n1.00\n1.00\n1.00\n1.00\n4.00\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\nlat_deg_original\n4760\n0.00\nNaN\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\nlon_deg_original\n4760\n0.00\nNaN\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\ncount\n0\n1.00\n1.00\n0.00\n1.00\n1.00\n1.00\n1.00\n1.00\n‚ñÅ‚ñÅ‚ñá‚ñÅ‚ñÅ\n\n\n\n\n\nAs observed, 'water_point_population' and 'local_population_1km' have 4 missing values. We can easily remove these datapoints since the count is\nWe also observed that 'usage_capacity' is numerical. However, we know that there are only 2 possible values, 300 and 1000. Given the context of the variable, this is a categorical variable.\nThe code chunk below removes any records that have NA values and converts the data type of 'usage_capacity' to factor.\n\n\nPress to toggle code\nosun_wp_sf_clean <- osun_wp_sf %>% \n  # Removes NAs\n  filter_at(vars(status,\n                 distance_to_primary_road,\n                 distance_to_secondary_road,\n                 distance_to_tertiary_road,\n                 distance_to_city,\n                 distance_to_town,\n                 water_point_population,\n                 local_population_1km,\n                 usage_capacity,\n                 is_urban,\n                 water_source_clean), \n            all_vars(!is.na(.))) %>% \n  # Changes usage_capacity to categorical value\n  mutate(usage_capacity = as.factor(usage_capacity))\n\n\nAs shown in the screenshot below, our new clean sf object has 4 less records."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#convert-sf-to-sp",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#convert-sf-to-sp",
    "title": "In-class Exercise 5",
    "section": "Convert sf to sp",
    "text": "Convert sf to sp\nBecause gwmodel can only perform functions on sp objects, we need to convert our sf object using as_Spatial().\n\n\nPress to toggle code\nosun_wp_sp <- osun_wp_sf_clean %>% \n  select(c(status,\n           distance_to_primary_road,\n           distance_to_secondary_road,\n           distance_to_tertiary_road,\n           distance_to_city,\n           distance_to_town,\n           water_point_population,\n           local_population_1km,\n           is_urban,\n           usage_capacity,\n           water_source_clean)) %>% \n  as_Spatial()\n\nosun_wp_sp\n\n\nclass       : SpatialPointsDataFrame \nfeatures    : 4756 \nextent      : 182502.4, 290751, 340054.1, 450905.3  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=4 +lon_0=8.5 +k=0.99975 +x_0=670553.98 +y_0=0 +a=6378249.145 +rf=293.465 +towgs84=-92,-93,122,0,0,0,0 +units=m +no_defs \nvariables   : 11\nnames       : status, distance_to_primary_road, distance_to_secondary_road, distance_to_tertiary_road, distance_to_city, distance_to_town, water_point_population, local_population_1km, is_urban, usage_capacity, water_source_clean \nmin values  :      0,        0.014461356813335,          0.152195902540837,         0.017815121653488, 53.0461399623541, 30.0019777713073,                      0,                    0,        0,           1000,           Borehole \nmax values  :      1,         26909.8616132094,           19559.4793799085,          10966.2705628969,  47934.343603562, 44020.6393368124,                  29697,                36118,        1,            300,   Protected Spring"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#building-fixed-bandwidth",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#building-fixed-bandwidth",
    "title": "In-class Exercise 5",
    "section": "Building Fixed Bandwidth",
    "text": "Building Fixed Bandwidth\n\n\nPress to toggle code\nbw.fixed <- bw.ggwr(status ~\n                 distance_to_primary_road + \n                 distance_to_secondary_road + \n                 distance_to_tertiary_road +\n                 distance_to_city +\n                 distance_to_town +\n                 water_point_population +\n                 local_population_1km +\n                 usage_capacity +\n                 is_urban +\n                 water_source_clean,\n                 data = osun_wp_sp,\n                 family = \"binomial\",\n                 approach = \"AIC\",\n                 kernel = \"gaussian\",\n                 adaptive = FALSE,\n                 longlat = FALSE)\n\n\nTake a cup of tea and have a break, it will take a few minutes.\n          -----A kind suggestion from GWmodel development group\n Iteration    Log-Likelihood:(With bandwidth:  95768.67 )\n=========================\n       0        -2889 \n       1        -2836 \n       2        -2830 \n       3        -2829 \n       4        -2829 \n       5        -2829 \nFixed bandwidth: 95768.67 AICc value: 5684.357 \n Iteration    Log-Likelihood:(With bandwidth:  59200.13 )\n=========================\n       0        -2875 \n       1        -2818 \n       2        -2810 \n       3        -2808 \n       4        -2808 \n       5        -2808 \nFixed bandwidth: 59200.13 AICc value: 5646.785 \n Iteration    Log-Likelihood:(With bandwidth:  36599.53 )\n=========================\n       0        -2847 \n       1        -2781 \n       2        -2768 \n       3        -2765 \n       4        -2765 \n       5        -2765 \n       6        -2765 \nFixed bandwidth: 36599.53 AICc value: 5575.148 \n Iteration    Log-Likelihood:(With bandwidth:  22631.59 )\n=========================\n       0        -2798 \n       1        -2719 \n       2        -2698 \n       3        -2693 \n       4        -2693 \n       5        -2693 \n       6        -2693 \nFixed bandwidth: 22631.59 AICc value: 5466.883 \n Iteration    Log-Likelihood:(With bandwidth:  13998.93 )\n=========================\n       0        -2720 \n       1        -2622 \n       2        -2590 \n       3        -2581 \n       4        -2580 \n       5        -2580 \n       6        -2580 \n       7        -2580 \nFixed bandwidth: 13998.93 AICc value: 5324.578 \n Iteration    Log-Likelihood:(With bandwidth:  8663.649 )\n=========================\n       0        -2601 \n       1        -2476 \n       2        -2431 \n       3        -2419 \n       4        -2417 \n       5        -2417 \n       6        -2417 \n       7        -2417 \nFixed bandwidth: 8663.649 AICc value: 5163.61 \n Iteration    Log-Likelihood:(With bandwidth:  5366.266 )\n=========================\n       0        -2436 \n       1        -2268 \n       2        -2194 \n       3        -2167 \n       4        -2161 \n       5        -2161 \n       6        -2161 \n       7        -2161 \n       8        -2161 \n       9        -2161 \nFixed bandwidth: 5366.266 AICc value: 4990.587 \n Iteration    Log-Likelihood:(With bandwidth:  3328.371 )\n=========================\n       0        -2157 \n       1        -1922 \n       2        -1802 \n       3        -1739 \n       4        -1713 \n       5        -1713 \nFixed bandwidth: 3328.371 AICc value: 4798.288 \n Iteration    Log-Likelihood:(With bandwidth:  2068.882 )\n=========================\n       0        -1751 \n       1        -1421 \n       2        -1238 \n       3        -1133 \n       4        -1084 \n       5        -1084 \nFixed bandwidth: 2068.882 AICc value: 4837.017 \n Iteration    Log-Likelihood:(With bandwidth:  4106.777 )\n=========================\n       0        -2297 \n       1        -2095 \n       2        -1997 \n       3        -1951 \n       4        -1938 \n       5        -1936 \n       6        -1936 \n       7        -1936 \n       8        -1936 \nFixed bandwidth: 4106.777 AICc value: 4873.161 \n Iteration    Log-Likelihood:(With bandwidth:  2847.289 )\n=========================\n       0        -2036 \n       1        -1771 \n       2        -1633 \n       3        -1558 \n       4        -1525 \n       5        -1525 \nFixed bandwidth: 2847.289 AICc value: 4768.192 \n Iteration    Log-Likelihood:(With bandwidth:  2549.964 )\n=========================\n       0        -1941 \n       1        -1655 \n       2        -1503 \n       3        -1417 \n       4        -1378 \n       5        -1378 \nFixed bandwidth: 2549.964 AICc value: 4762.212 \n Iteration    Log-Likelihood:(With bandwidth:  2366.207 )\n=========================\n       0        -1874 \n       1        -1573 \n       2        -1410 \n       3        -1316 \n       4        -1274 \n       5        -1274 \nFixed bandwidth: 2366.207 AICc value: 4773.081 \n Iteration    Log-Likelihood:(With bandwidth:  2663.532 )\n=========================\n       0        -1979 \n       1        -1702 \n       2        -1555 \n       3        -1474 \n       4        -1438 \n       5        -1438 \nFixed bandwidth: 2663.532 AICc value: 4762.568 \n Iteration    Log-Likelihood:(With bandwidth:  2479.775 )\n=========================\n       0        -1917 \n       1        -1625 \n       2        -1468 \n       3        -1380 \n       4        -1339 \n       5        -1339 \nFixed bandwidth: 2479.775 AICc value: 4764.294 \n Iteration    Log-Likelihood:(With bandwidth:  2593.343 )\n=========================\n       0        -1956 \n       1        -1674 \n       2        -1523 \n       3        -1439 \n       4        -1401 \n       5        -1401 \nFixed bandwidth: 2593.343 AICc value: 4761.813 \n Iteration    Log-Likelihood:(With bandwidth:  2620.153 )\n=========================\n       0        -1965 \n       1        -1685 \n       2        -1536 \n       3        -1453 \n       4        -1415 \n       5        -1415 \nFixed bandwidth: 2620.153 AICc value: 4761.89 \n Iteration    Log-Likelihood:(With bandwidth:  2576.774 )\n=========================\n       0        -1950 \n       1        -1667 \n       2        -1515 \n       3        -1431 \n       4        -1393 \n       5        -1393 \nFixed bandwidth: 2576.774 AICc value: 4761.889 \n Iteration    Log-Likelihood:(With bandwidth:  2603.584 )\n=========================\n       0        -1960 \n       1        -1678 \n       2        -1528 \n       3        -1445 \n       4        -1407 \n       5        -1407 \nFixed bandwidth: 2603.584 AICc value: 4761.813 \n Iteration    Log-Likelihood:(With bandwidth:  2609.913 )\n=========================\n       0        -1962 \n       1        -1680 \n       2        -1531 \n       3        -1448 \n       4        -1410 \n       5        -1410 \nFixed bandwidth: 2609.913 AICc value: 4761.831 \n Iteration    Log-Likelihood:(With bandwidth:  2599.672 )\n=========================\n       0        -1958 \n       1        -1676 \n       2        -1526 \n       3        -1443 \n       4        -1405 \n       5        -1405 \nFixed bandwidth: 2599.672 AICc value: 4761.809 \n Iteration    Log-Likelihood:(With bandwidth:  2597.255 )\n=========================\n       0        -1957 \n       1        -1675 \n       2        -1525 \n       3        -1441 \n       4        -1403 \n       5        -1403 \nFixed bandwidth: 2597.255 AICc value: 4761.809 \n\n\nPress to toggle code\n        # since our data is projected, set longlat = FALSE\n\n\n\n\nPress to toggle code\nbw.fixed\n\n\n[1] 2599.672\n\n\nThe result is 2599.67 km.\n\n\nPress to toggle code\ngwlr.fixed <- ggwr.basic(status ~ \n                 distance_to_primary_road + \n                 distance_to_secondary_road + \n                 distance_to_tertiary_road +\n                 distance_to_city +\n                 distance_to_town +\n                 water_point_population +\n                 local_population_1km +\n                 usage_capacity +\n                 is_urban +\n                 water_source_clean,\n                 data = osun_wp_sp,\n                 bw = bw.fixed,\n                 family = \"binomial\",\n                 kernel = \"gaussian\",\n                 adaptive = FALSE,\n                 longlat = FALSE)\n\n\n Iteration    Log-Likelihood\n=========================\n       0        -1958 \n       1        -1676 \n       2        -1526 \n       3        -1443 \n       4        -1405 \n       5        -1405 \n\n\nPress to toggle code\ngwlr.fixed\n\n\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n   Program starts at: 2022-12-17 23:24:00 \n   Call:\n   ggwr.basic(formula = status ~ distance_to_primary_road + distance_to_secondary_road + \n    distance_to_tertiary_road + distance_to_city + distance_to_town + \n    water_point_population + local_population_1km + usage_capacity + \n    is_urban + water_source_clean, data = osun_wp_sp, bw = bw.fixed, \n    family = \"binomial\", kernel = \"gaussian\", adaptive = FALSE, \n    longlat = FALSE)\n\n   Dependent (y) variable:  status\n   Independent variables:  distance_to_primary_road distance_to_secondary_road distance_to_tertiary_road distance_to_city distance_to_town water_point_population local_population_1km usage_capacity is_urban water_source_clean\n   Number of data points: 4756\n   Used family: binomial\n   ***********************************************************************\n   *              Results of Generalized linear Regression               *\n   ***********************************************************************\n\nCall:\nNULL\n\nDeviance Residuals: \n     Min        1Q    Median        3Q       Max  \n-124.555    -1.755     1.072     1.742    34.333  \n\nCoefficients:\n                                           Estimate Std. Error z value Pr(>|z|)\nIntercept                                 3.887e-01  1.124e-01   3.459 0.000543\ndistance_to_primary_road                 -4.642e-06  6.490e-06  -0.715 0.474422\ndistance_to_secondary_road               -5.143e-06  9.299e-06  -0.553 0.580230\ndistance_to_tertiary_road                 9.683e-05  2.073e-05   4.671 3.00e-06\ndistance_to_city                         -1.686e-05  3.544e-06  -4.757 1.96e-06\ndistance_to_town                         -1.480e-05  3.009e-06  -4.917 8.79e-07\nwater_point_population                   -5.097e-04  4.484e-05 -11.369  < 2e-16\nlocal_population_1km                      3.451e-04  1.788e-05  19.295  < 2e-16\nusage_capacity1000                       -6.230e-01  6.972e-02  -8.937  < 2e-16\nis_urbanTRUE                             -2.971e-01  8.185e-02  -3.629 0.000284\nwater_source_cleanProtected Shallow Well  5.040e-01  8.574e-02   5.878 4.14e-09\nwater_source_cleanProtected Spring        1.288e+00  4.388e-01   2.936 0.003325\n                                            \nIntercept                                ***\ndistance_to_primary_road                    \ndistance_to_secondary_road                  \ndistance_to_tertiary_road                ***\ndistance_to_city                         ***\ndistance_to_town                         ***\nwater_point_population                   ***\nlocal_population_1km                     ***\nusage_capacity1000                       ***\nis_urbanTRUE                             ***\nwater_source_cleanProtected Shallow Well ***\nwater_source_cleanProtected Spring       ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 6534.5  on 4755  degrees of freedom\nResidual deviance: 5688.0  on 4744  degrees of freedom\nAIC: 5712\n\nNumber of Fisher Scoring iterations: 5\n\n\n AICc:  5712.099\n Pseudo R-square value:  0.1295351\n   ***********************************************************************\n   *          Results of Geographically Weighted Regression              *\n   ***********************************************************************\n\n   *********************Model calibration information*********************\n   Kernel function: gaussian \n   Fixed bandwidth: 2599.672 \n   Regression points: the same locations as observations are used.\n   Distance metric: A distance matrix is specified for this model calibration.\n\n   ************Summary of Generalized GWR coefficient estimates:**********\n                                                   Min.     1st Qu.      Median\n   Intercept                                -8.7228e+02 -4.9955e+00  1.7600e+00\n   distance_to_primary_road                 -1.9389e-02 -4.8031e-04  2.9618e-05\n   distance_to_secondary_road               -1.5921e-02 -3.7551e-04  1.2317e-04\n   distance_to_tertiary_road                -1.5618e-02 -4.2368e-04  7.6179e-05\n   distance_to_city                         -1.8416e-02 -5.6217e-04 -1.2726e-04\n   distance_to_town                         -2.2411e-02 -5.7283e-04 -1.5155e-04\n   water_point_population                   -5.2208e-02 -2.2767e-03 -9.8875e-04\n   local_population_1km                     -1.2698e-01  4.9952e-04  1.0638e-03\n   usage_capacity1000                       -2.0772e+01 -9.7231e-01 -4.1592e-01\n   is_urbanTRUE                             -1.9790e+02 -4.2908e+00 -1.6864e+00\n   water_source_cleanProtected.Shallow.Well -2.0789e+01 -4.5190e-01  5.3340e-01\n   water_source_cleanProtected.Spring       -5.2235e+02 -5.5977e+00  2.5441e+00\n                                                3rd Qu.      Max.\n   Intercept                                 1.2763e+01 1073.2154\n   distance_to_primary_road                  4.8443e-04    0.0142\n   distance_to_secondary_road                6.0692e-04    0.0258\n   distance_to_tertiary_road                 6.6814e-04    0.0128\n   distance_to_city                          2.3718e-04    0.0150\n   distance_to_town                          1.9271e-04    0.0224\n   water_point_population                    5.0102e-04    0.1309\n   local_population_1km                      1.8157e-03    0.0392\n   usage_capacity1000                        3.0322e-01    5.9281\n   is_urbanTRUE                              1.2841e+00  744.3097\n   water_source_cleanProtected.Shallow.Well  1.7849e+00   67.6343\n   water_source_cleanProtected.Spring        6.7663e+00  317.4123\n   ************************Diagnostic information*************************\n   Number of data points: 4756 \n   GW Deviance: 2795.084 \n   AIC : 4414.606 \n   AICc : 4747.423 \n   Pseudo R-square value:  0.5722559 \n\n   ***********************************************************************\n   Program stops at: 2022-12-17 23:24:32 \n\n\nAs observed from above, the AIC values dropped down from 5712.10 to 4414.61."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#converting-sdf-into-sf-data.frame",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#converting-sdf-into-sf-data.frame",
    "title": "In-class Exercise 5",
    "section": "Converting SDF into sf data.frame",
    "text": "Converting SDF into sf data.frame\n\n\nPress to toggle code\ngwr.fixed <- as.data.frame(gwlr.fixed$SDF)\n\n\nSince 'yhat' is probability, we need to create a new logical column called 'most' to label as 1 or 0 if the 'yhat' is greater or equal to 0.5.\n\n\nPress to toggle code\ngwr.fixed <- gwr.fixed %>% \n  mutate(most = ifelse(\n    gwr.fixed$yhat >= 0.5, T, F))\n\n\nThe code chunk below creates the confustion matrix of the model.\n\n\nPress to toggle code\ngwr.fixed$y <- as.factor(gwr.fixed$y)\n\ngwr.fixed$most <- as.factor(gwr.fixed$most)\n\nCM <- confusionMatrix(data = gwr.fixed$most, reference = gwr.fixed$y)\n\nCM\n\n\nConfusion Matrix and Statistics\n\n          Reference\nPrediction FALSE TRUE\n     FALSE  1824  263\n     TRUE    290 2379\n                                          \n               Accuracy : 0.8837          \n                 95% CI : (0.8743, 0.8927)\n    No Information Rate : 0.5555          \n    P-Value [Acc > NIR] : <2e-16          \n                                          \n                  Kappa : 0.7642          \n                                          \n Mcnemar's Test P-Value : 0.2689          \n                                          \n            Sensitivity : 0.8628          \n            Specificity : 0.9005          \n         Pos Pred Value : 0.8740          \n         Neg Pred Value : 0.8913          \n             Prevalence : 0.4445          \n         Detection Rate : 0.3835          \n   Detection Prevalence : 0.4388          \n      Balanced Accuracy : 0.8816          \n                                          \n       'Positive' Class : FALSE           \n                                          \n\n\n\n\nPress to toggle code\nosun_wp_sf_selected <- osun_wp_sf_clean %>% \n  select(c(ADM2_EN, ADM2_PCODE,\n           ADM1_EN, ADM1_PCODE,\n           status))\n\n\nThe logistic regression model has accuracy of 88.37%, sensitivity of 86.28%, and specificity of 90.05%.\nThe code chunk below combines our water point data and model.\n\n\nPress to toggle code\ngwr_sf.fixed <- cbind(osun_wp_sf_selected, gwr.fixed)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-coefficient-estimates",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-coefficient-estimates",
    "title": "In-class Exercise 5",
    "section": "Visualizing Coefficient Estimates",
    "text": "Visualizing Coefficient Estimates\nThe code chunk below creates an interactive point map of the probability.\n\n\nPress to toggle code\ntmap_mode(\"view\")\nprob_T <- tm_shape(osun) + \n  tm_polygons(alpha = 0.1) + \n  tm_shape(gwr_sf.fixed) + \n  tm_dots(col = \"yhat\",\n          palette = \"RdPu\",\n          border.col = \"#704276\",\n          border.lwd = 1) +\n  tm_view(set.zoom.limits = c(8,14))\n\nprob_T"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "",
    "text": "The use of geospatial analytics can be beneficial in addressing different complex problems in society. As a sample use case, we will be applying different local and global measures of spatial autocorrelation to reveal spatial patterns in the status of water points in the country of Nigeria.\n\n\n\n\n\nImage of Nigerian child drinking from water point courtesy of ¬©UNICEFNigeria/2020\n\n\n\n‚ÄúThe sea, once it casts its spell, holds one in its net of wonder forever. Water and air, the two essential fluids on which all life depends, have become global garbage cans. We forget that the water cycle and life cycle are one.‚Äù\n-- Jacques Yves Coseau, Famous Oceanographer\n\nWater is the root of all life, and yet access to such an important resource is not universally met. Inaccessibility to water negatively impacts health and other aspects of life. According to UNICEF, 785 million people today do not have basic access to water and back in March 2021 it was reported that 1 in 5 children worldwide do not have enough water. How are children supposed to areas where water is not readily available?\nThe figures in Nigeria report that a staggering 26.5 million children are experiencing high or extremely high water vulnerability. This means water sources are scarce or are of poor quality.\nThe Water Point Data Exchange (WPdx) is a data collection project with the goal of encouraging evidence-based decision-making that improves rural water services using water point data. Using core parameters that are commonly measured by governments, non-governmental organizations, and researchers are set by the WPdx Data Standard. The data can be found in the WPdx Data Repository.\n\n\n\nIn culmination of the first four chapters of ‚ÄúR for Geospatial Data Science and Analytics‚Äù and first two lessons of ISSS624, this is my submission for Take-home Exercise 1. The following objectives were accomplished in this Take-home Exercise:\n\nUse the appropriate sf methods, import the geospatial data into R and save it in a simple feature data frame format.\nUse the appropriate tidyr and dplyr methods, derive the proportion of functional and non-functional water point at LGA level.\nPerform outliers/clusters analysis using appropriate local measures of spatial association methods.\nPerform hotspot area analysis by using appropriate local measures of spatial association methods.\nPlot maps to show the spatial distribution of functional and non-functional water point rate at LGA level by using appropriate thematic mapping technique provided by the tmap package.\nPlot hotspot areas and outliers/clusters maps of functional and non-functional water point rate at LGA level by using appropriate thematic mapping technique provided by the tmap package."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#acquiring-the-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#acquiring-the-data",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Acquiring the Data",
    "text": "Acquiring the Data\nThere are two important geospatial datasets to access which will be expounded upon below.\n\nAdministrative Boundaries of Nigeria\nFirst we have the Level-2 Administrative Boundary (A.K.A. Local Government Area) of Nigeria, as sourced from geoBoundaries. The screenshot attached shows where to acquire the dataset.\n\n\n\nScreenshot of Nigeria‚Äôs ADM2 boundary polygon features GIS data source from geoBoundaries\n\n\nThe downloaded ZIP file will contain GIS data for the regular and simplified boundaries. For the purpose of this study, we will not use the simplified data. All related files were renamed to ‚ÄúgeoBoundaries‚Äù for simplicity‚Äôs sake.\n\n\nWater Point Data\nTo be able to analyze the water points of different areas, we‚Äôll need the data from Water Point Data Exchange (WPdx) Repository as mentioned previously. There are two versions, WPdx-Basic and WPdx+. For this take-home exercise, we are making use of WPdx+.\n\n\n\nScreenshot of Water Point Data Exchange Plus data source from https://data.waterpointdata.org/\n\n\nThe site allows us to export the data in different file formats. For this exercise, I downloaded the Shapefile for familiarity. To simplify the filename, all related files were renamed to ‚Äúgeo_export‚Äù."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#loading-in-the-required-packages",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#loading-in-the-required-packages",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Loading in the Required Packages",
    "text": "Loading in the Required Packages\nTo get started on coding with R, we need to first load the necessary packages that will help us with the processes. In the code chunk below, p_load() of the pacman package is used to install and load the following R packages into R environment:\n\nsf - support for simple features, a standardized way to encode spatial vector data\ntidyverse - core packages for data analyses\ntmap - used for thematic plotting of maps\nspedep - a library for creating spacial weights\n\n\n\nPress to toggle code\npacman::p_load(sf, tidyverse, tmap, spdep)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#importing-the-geospatial-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#importing-the-geospatial-data",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Importing the Geospatial Data",
    "text": "Importing the Geospatial Data\n\nImporting the LGA boundary data of Nigeria\nUsing the st_read() function of the sf package, the code chunk below creates a simple features data table from the geoBoundaries shapefile.\n\n\nPress to toggle code\nnga_bounds <- st_read(dsn = \"data\", layer = \"geoBoundaries\", crs = 4326)\n\n\n\n\n\n\n\nNigeria has 774 local government areas (LGAs). The terms ‚ÄúLGA‚Äù, ‚Äúshape‚Äù, ‚Äúpolygon‚Äù,‚Äúregion‚Äù and ‚Äúfeatures‚Äù will be used interchangeable from this point forward in the take-home exercise.\n\n\nImporting the water point data of Nigeria\nSimilarly above, we once again use st_read() to import the geo_export shapefile. However, this time we need to use the filter() function to make sure that we only extract the data related to Nigeria. The code snippet filter(clean_coun == \"Nigeria\") does just this, where ‚Äòclean_coun‚Äô is the column from the data table referring to the country name and == asks for the records set as ‚ÄúNigeria‚Äù.\n\n\nPress to toggle code\nnga_wp <- st_read(dsn = \"data\", layer = \"geo_export\", crs = 4326) %>% filter(clean_coun == \"Nigeria\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCODE REVIEW!\n\n\n\nWhat does %>% do?\nIt‚Äôs an operator that is part of the dplyr package that passes the left-hand side of the operator as the first argument of the function on the right-hand side.\n\n\nWe end up with a data table containing 95,008 records and 73 variables. The geometry type is POINT, meaning each record is a point relative to the coordinate system. The records refer to different water points in Nigeria with different descriptions such as status, water source, usage capacity, etc."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#data-wrangling",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Data Wrangling",
    "text": "Data Wrangling\nData, when collected, is very raw and isn‚Äôt perfect. Sometimes some magic needs to be done to shape the data into something that is usable for the analytical process. In this section, we try to collate the individual water point data to usable attributes that describe the ratio of functional water points per LGA.\nIn the previous section we ended up with a data table that has 73 variables. That sounds like a lot because it is! Since the objective of this exercise is only related to the functionality of different water points, we are mostly interested in the different statuses of each water point.\n\nChecking and replacing N/A values in 'status_cle'\nSince our primary focus is the status of each water point, we need to take a look at the variable 'status_cle'. It would be very problematic if there were empty values. To check we use the code chunk below:\n\n\nPress to toggle code\nsum(is.na(nga_wp$status_cle))\n\n\n\n\n\n\n\nThis code chunk adds up all the cells in 'status_cle' that return TRUE from the is.na() function. The result tells us that there are 10,656 missing cells. That‚Äôs a lot! What do we do with them?\nThe code chunk below uses mutate() to replace the current 'status_cle'column with one where replace_na() is applied. The function replace_na replaces N/A values in a column with the second argument, in this case ‚ÄúUnknown‚Äù.\n\n\nPress to toggle code\nnga_wp <- nga_wp %>% mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\n\nBy running the previous code chunk we can verify that there are no more N/A values.\n\n\nPress to toggle code\nsum(is.na(nga_wp$status_cle))\n\n\n\n\n\nRegionalizing water point data\nSo we have the individual water points, but how do we translate it in such a way that we can compare it for each LGA?\n\nTranslating to Functional and Non-Functional\nFirst, the code chunk below makes use of unique() to output the set of all unique values in the column.\n\n\nPress to toggle code\nunique(nga_wp$status_cle)\n\n\n\n\n\n\n\nThe output shows that there are 7 different status values. However, some of them fall under the same status umbrella of either ‚ÄúFunctional‚Äù or ‚ÄúNon-Functional‚Äù, they just contain extra information.\n\n\nPress to toggle code\nwpt_functional <- nga_wp %>% filter(status_cle %in% c(\"Functional\", \"Functional but not in use\", \"Functional but needs repair\"))\n\n\n\n\n\n\n\nThe code chunk above extracts all the records that have the following statuses: ‚ÄúFunctional‚Äù, ‚ÄúFunctional but not in use‚Äù, and ‚ÄúFunctional but needs repair‚Äù using the filter() function as saves to 'wpt_functional'.\n\n\nPress to toggle code\nwpt_nonfunctional <- nga_wp %>% filter(status_cle %in% c(\"Abandoned/Decommissioned\", \"Abandoned\", \"Non-Functional\", \"Non functional due to dry season\", \"Non-Functional due to dry season\"))\n\n\n\n\n\n\n\nSimilarly, the code chunk above extracts all the records that have the following statuses: ‚ÄúAbandoned/Decommissioned‚Äù, ‚ÄúAbandoned‚Äù, ‚ÄúNon-Functional‚Äù, ‚ÄúNon functional due to dry season‚Äù, and ‚ÄúNon-Functional due to dry season‚Äù and saves them to 'wpt_nonfunctional'.\n\n\nPress to toggle code\nwpt_unknown <- nga_wp %>% filter(status_cle == \"Unknown\")\n\n\n\n\n\n\n\nLastly, we do the same for all records with the status ‚ÄúUnknown‚Äù and save it to 'wpt_unknown'.\n\n\nPerforming point-in-polygon count\nThis is where the magic happens. Since we know the individual water points (as POINT data), we can see where they overlap with the polygons (LGAs) to determine regional data. The function st_intersects() returns true if two geometries intersect, meaning if the water point is found within the polygon boundary of an LGA, it will return true. The function lengths() gives the number of true values (or count) returned from st_intersects().\nNew columns are then added to our original boundary data 'nga_bounds' which dictate the count of total, functional, non-functional, and unknown water points per LGA.\n\n\nPress to toggle code\nnga_wp_final <- nga_bounds %>% mutate(`total_wpt` = lengths(st_intersects(nga_bounds, nga_wp))) %>% mutate(`wpt_functional` = lengths(st_intersects(nga_bounds, wpt_functional))) %>% mutate(`wpt_nonfunctional` = lengths(st_intersects(nga_bounds, wpt_nonfunctional))) %>% mutate(`wpt_unknown` = lengths(st_intersects(nga_bounds, wpt_unknown)))\n\n\n\n\n\n\n\n\n\nGetting the percentage of functional and non-functional water points\nNot all regions are made equal. It wouldn‚Äôt make sense to compare the number of water points in a smaller region to a bigger region because it‚Äôs possible that larger land area would contribute to having more water points. To give a better analysis of the collective water point status per region, we can get the percentage or ratio of functional and non-functional water points.\nThe code chunk below adds two new columns to our dataframe, which contain the percentage of functional and non-functional water points.\n\n\nPress to toggle code\nnga_wp_final <- nga_wp_final %>% mutate(`pct_functional` = `wpt_functional`/`total_wpt`) %>% mutate(`pct_nonfunctional` = `wpt_nonfunctional`/`total_wpt`)\n\n\nUnfortunately, some of the regions either don‚Äôt have water points or their data is not recorded. Because of this, performing the division above to get the percentages may lead to NaN values when getting the percentages. A sample is shown for the LGA ‚ÄúAbadam‚Äù.\n\n\n\n\n\nTo fix this, we replace the NaN values with a value of 0 using the code chunk below. The function replace_na() which was used earlier for empty cells, also works for NaN values.\n\n\nPress to toggle code\nnga_wp_final <- nga_wp_final %>% mutate(pct_functional = replace_na(pct_functional, 0)) %>% mutate(pct_nonfunctional= replace_na(pct_nonfunctional, 0))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#projecting-the-coordinate-reference-system",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#projecting-the-coordinate-reference-system",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Projecting the Coordinate Reference System",
    "text": "Projecting the Coordinate Reference System\nSince the source of our boundary file was an international source, the CRS in use is geographic. What this means is the points are plotted on the earth‚Äôs surface, which is ellipsoid. We need transform the data to the appropriate projected CRS, which will be plotted on a flat surface. Different countries also use different projected CRSs.\n\n\nPress to toggle code\nst_crs(nga_wp_final)\n\n\n\n\n\n\n\nThe code chunk below uses st_transform to transform 'nga_wp_final' to EPSG Code 26392, which is one of the projected coordinate reference systems used for Nigeria.\n\n\nPress to toggle code\nnga_wp_final <- st_transform(nga_wp_final, crs = 26392)\n\n\nChecking if the CRS changed, we have the results below.\n\n\nPress to toggle code\nst_crs(nga_wp_final)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#saving-the-analytical-data-table",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#saving-the-analytical-data-table",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Saving the Analytical Data Table",
    "text": "Saving the Analytical Data Table\nNow that we‚Äôve completed adjusting our data, we can save the new dataset as an RDS file. RDS files are data files native to R. The code chunk below saves our spatial dataframe ‚Äònga_wp_final‚Äô into an RDS file called ‚Äúnga_wp_final.rds‚Äù.\n\n\nPress to toggle code\nwrite_rds(nga_wp_final, \"data/nga_wp_final.rds\")\n\n\nWe can now reload the dataset back to R using read_rds as shown in the code chunk below.\n\n\nPress to toggle code\nnga_wp_final <- read_rds(\"data/nga_wp_final.rds\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#distribution-of-functional-water-point",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#distribution-of-functional-water-point",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Distribution of Functional Water Point (%)",
    "text": "Distribution of Functional Water Point (%)\n\n\nPress to toggle code\nggplot(nga_wp_final, aes(pct_functional)) + geom_histogram(fill = \"#ffb7b1\", color = \"black\", binwidth=0.1)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#distribution-of-non-functional-water-point",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#distribution-of-non-functional-water-point",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Distribution of Non-Functional Water Point (%)",
    "text": "Distribution of Non-Functional Water Point (%)\n\n\nPress to toggle code\nggplot(nga_wp_final, aes(pct_nonfunctional)) + geom_histogram(fill = \"#ffb7b1\", color = \"black\", binwidth=0.1)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#mapping-the-distribution-of-function-and-non-functional-water-points",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#mapping-the-distribution-of-function-and-non-functional-water-points",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Mapping the Distribution of Function and Non-Functional Water Points",
    "text": "Mapping the Distribution of Function and Non-Functional Water Points\nThe function qtm() is a handy function that stands for ‚Äúquick thematic mapping‚Äù and provides an easy way of visualizing geospatial data by default. To see the distribution of both functional and non-functional water point percentages, we run the code chunk below. By setting the 'fill' argument as either 'pct_functional' or 'pct_nonfunctional', we can create a chloropleth mapping of the corresponding attribute.\n\n\nPress to toggle code\n# Functional Water Point Distribution\npct_functional.map <- qtm(nga_wp_final, fill = \"pct_functional\", fill.palette = \"RdPu\", fill.title = \"Percentage (%)\", borders = \"black\", title = \"Distribution of Functional Water Points (%)\") + tm_legend(legend.height = 0.25)\n\n# Non-Functional Water Point Distribution\npct_nonfunctional.map <- qtm(nga_wp_final, fill = \"pct_nonfunctional\", fill.palette = \"RdPu\", fill.title = \"Percentage (%)\", borders = \"black\", title = \"Distribution of Non-Functional Water Points (%)\") + tm_legend(legend.height = 0.25)\n\ntmap_arrange (pct_functional.map, pct_nonfunctional.map, ncol = 2, asp = 1)\n\n\n\n\n\n\n\n\n\n\n\nFIRST IMPRESSIONS!\n\n\n\nBased on the default chloropleth mapping of the percentages without spatial lag, there are a few observations that can be made:\n\nThe northern area seems to have a higher percentage of functional water points since the left mapping has purple shades, while the right mapping has the lightest pink shades.\nThe northeastern area where both mappings contain the lightest pink shades probably have unknown water point values. This seems to indicate that something should be done to be able to check the status of water points in that area.\nWhile it can‚Äôt be fully concluded, but it does make sense that the colors for each LGA are inversely proportional."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#defining-the-spatial-weights-matrix",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#defining-the-spatial-weights-matrix",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Defining the Spatial Weights Matrix",
    "text": "Defining the Spatial Weights Matrix\nBefore we can compute for the different statistical measures though, we need to define the neighbors of each feature and their relationship defined by spatial weights.\nThere are different ways to construct the spatial weights matrix and it depends on how neighbors are defined. For this study, we will be using adaptive distance-based spatial weights.\n\nGetting the centroids\nSince distance is being measured and we are using polygons, we need to define centroids, which are the points geometric centers of polygons. These are the values that will determine ‚Äúdistance‚Äù between the features. The code chunk below uses st_centroid() to create a POINT type spatial dataframe containing all the centroids of our LGAs or features as computed from the st_geometry() values.\n\n\nPress to toggle code\ncoords <- st_centroid(st_geometry(nga_wp_final))\ncoords\n\n\nGeometry set for 774 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 39384.4 ymin: 41598.31 xmax: 1322777 ymax: 1073546\nProjected CRS: Minna / Nigeria Mid Belt\nFirst 5 geometries:\n\n\n\n\nCreating neighbors list using adaptive distance\nUsing the function knn2nb() we can turn the list of k-neareset points from knearneigh() to a list of neighbors per feature. The argument 'k' sets the number of neighbors. The code chunk defines 8 neighboring LGAs for each LGA.\n\n\nPress to toggle code\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n\n\nNeighbour list object:\nNumber of regions: 774 \nNumber of nonzero links: 6192 \nPercentage nonzero weights: 1.033592 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\n\n\n\n\n\n\nCODE REVIEW!\n\n\n\nThe function knearneigh() has the argument 'longlat' . We know that the projected coordinate system we are using doesn‚Äôt make use of longitude and latitude values. Why aren‚Äôt we setting 'longlat' to FALSE?\n\nAccording to the R documentation, if 'x' is a SpatialPoints object, the value is taken from the object itself. Since ‚Äòcoords‚Äô is a SpatialPoints object, there is no need to specify a FALSE value.\n\n\n\n\nCreating the binary spatial weights matrix\nThe previous code chunk only creates a list of neighbors. We need to use nb2listw() to create the spatial weight matrix. The argument 'style' dictates the encoding. In this case, we use basic binary encoding as represented by the value ‚ÄúB‚Äù.\n\n\nPress to toggle code\nknn_lw <- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 774 \nNumber of nonzero links: 6192 \nPercentage nonzero weights: 1.033592 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n  8 \n774 \n774 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 with 8 links\n774 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 with 8 links\n\nWeights style: B \nWeights constants summary:\n    n     nn   S0    S1     S2\nB 774 599076 6192 11152 201942\n\n\n\n\nVisualizing the adaptive distance-based neighbors\n\n\nPress to toggle code\nplot(nga_wp_final$geometry, border=\"lightgrey\", main=\"Adaptive Distance-based Neighbors of Nigeria LGAs\")\nplot(knn, coords, pch = 20, cex = 0.4, add=TRUE, col=\"#FF5A5A\", length=0.08)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#global-spatial-autocorrelation-morans-i",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#global-spatial-autocorrelation-morans-i",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Global Spatial Autocorrelation: Moran‚Äôs I",
    "text": "Global Spatial Autocorrelation: Moran‚Äôs I\n\n\n\n\n\n\nLESSON REVIEW!\n\n\n\nMoran‚Äôs I is a measure that describes how features differ from the values in the study area as a whole. It is defined as:\n\\[\nI = \\dfrac{N}{W}\\dfrac{\\displaystyle\\sum^N_{j=1}W_{ij}(x_i-\\bar{x})(x_j-\\bar{x})}{\\displaystyle\\sum^N_{i=1}(x_i-\\bar{x})^2}\n\\]\nWhere:\n\n\\(N\\) is the numbe of spatial units\n\\(x\\) is the variable\n\\(\\bar{x}\\) is the mean of x\n\\(w_{ij}\\) is a matrix of spatial weights with zeroes on the diagonal\n\\(W\\) is the sum of all \\(w_{ij}\\)\n\n\n\nThe package spdep provides a function moran.test() to simply perform Moran‚Äôs I statistics. The first test is the variable, the argument 'listw' contains the spatial weights matrix, and 'zero.policy' and 'na.action' just determine what to do for features without neighbors and N/A variable values.\n\nComputing Moran‚Äôs I statistic for 'pct_functional'\n\n\nPress to toggle code\nmoran.test(nga_wp_final$pct_functional, listw=knn_lw, zero.policy = TRUE, na.action=na.omit)\n\n\n\n    Moran I test under randomisation\n\ndata:  nga_wp_final$pct_functional  \nweights: knn_lw    \n\nMoran I statistic standard deviate = 31.161, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.5271813748     -0.0012936611      0.0002876224 \n\n\nBased on the results, the p-value being less than \\(2.2e^{-16}\\) , which is below 0.05, dictates that we can reject the null hypothesis stating that the variable 'pct_functional' is randomly distributed and do not depend on each other. The Moran I value of 0.5271813748 being statistically significant and positive dictates that 'pct_functional' values are clustered similarly.\n\n\nComputing Moran‚Äôs I statistic for 'pct_nonfunctional'\n\n\nPress to toggle code\nmoran.test(nga_wp_final$pct_nonfunctional, listw=knn_lw, zero.policy = TRUE, na.action=na.omit)\n\n\n\n    Moran I test under randomisation\n\ndata:  nga_wp_final$pct_nonfunctional  \nweights: knn_lw    \n\nMoran I statistic standard deviate = 27.281, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.4613158941     -0.0012936611      0.0002875562 \n\n\nBased on the results, the p-value being less than \\(2.2e^{-16}\\) , which is below 0.05, dictates that we can reject the null hypothesis stating that the variable 'pct_nonfunctional' is randomly distributed and do not depend on each other. The Moran I value of 0.4613158941 being statistically significant and positive dictates that 'pct_nonfunctional' values are clustered similarly.\n\n\nPlotting Moran I‚Äôs spatial correlogram for 'pct_functional' and 'pct_nonfunctional'\nSpatial correlograms are great to examine patterns of spatial autocorrelation. In this case, they show the Moran‚Äôs I when you increase the distance (spatial lag) between them.\n\n\nPress to toggle code\nMI_corr_fun <- sp.correlogram(knn, \n                          nga_wp_final$pct_functional, \n                          order=5, \n                          method=\"I\", \n                          style=\"B\")\n\n\nMI_corr_nonfun <- sp.correlogram(knn, \n                          nga_wp_final$pct_nonfunctional, \n                          order=5, \n                          method=\"I\", \n                          style=\"B\")\n\npar(mfrow=c(1,2))\nplot(MI_corr_fun, main = \"Functional\")\nplot(MI_corr_nonfun, main = \"Non-Functional\")\n\n\n\n\n\n\n\nPress to toggle code\nprint(MI_corr_fun)\n\n\nSpatial correlogram for nga_wp_final$pct_functional \nmethod: Moran's I\n           estimate expectation    variance standard deviate Pr(I) two sided\n1 (774)  5.2718e-01 -1.2937e-03  2.8762e-04           31.161       < 2.2e-16\n2 (774)  4.2140e-01 -1.2937e-03  1.3391e-04           36.527       < 2.2e-16\n3 (774)  3.5315e-01 -1.2937e-03  8.3863e-05           38.705       < 2.2e-16\n4 (774)  2.6765e-01 -1.2937e-03  6.0645e-05           34.535       < 2.2e-16\n5 (774)  2.2873e-01 -1.2937e-03  4.7707e-05           33.303       < 2.2e-16\n           \n1 (774) ***\n2 (774) ***\n3 (774) ***\n4 (774) ***\n5 (774) ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\nPress to toggle code\nprint(MI_corr_nonfun)\n\n\nSpatial correlogram for nga_wp_final$pct_nonfunctional \nmethod: Moran's I\n           estimate expectation    variance standard deviate Pr(I) two sided\n1 (774)  4.6132e-01 -1.2937e-03  2.8756e-04           27.281       < 2.2e-16\n2 (774)  3.2860e-01 -1.2937e-03  1.3388e-04           28.511       < 2.2e-16\n3 (774)  2.2169e-01 -1.2937e-03  8.3844e-05           24.352       < 2.2e-16\n4 (774)  1.2965e-01 -1.2937e-03  6.0631e-05           16.817       < 2.2e-16\n5 (774)  7.1147e-02 -1.2937e-03  4.7696e-05           10.489       < 2.2e-16\n           \n1 (774) ***\n2 (774) ***\n3 (774) ***\n4 (774) ***\n5 (774) ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Cluster and Outlier Analysis",
    "text": "Cluster and Outlier Analysis\nLocal Indicators of Spatial Association or LISA are statistical methods that indicate the existence of significant clustering in the spatial arrangement of a given variable around a feature.\n\nComputing local Moran‚Äôs I for 'pct_functional' and 'pct_nonfunctional'\nThe function localmoran() of the spdep package computes \\(I_i\\) values, given a set of \\(z_i\\) values and a listw object providing neighbor weighting information for the polygon associated with the \\(z_i\\) values.\n\n\nPress to toggle code\n# Functional \nlocalMI_fun <- localmoran(nga_wp_final$pct_functional, knn_lw, na.action = na.omit, zero.policy = TRUE)\n# Non-functional\nlocalMI_nonfun <- localmoran(nga_wp_final$pct_nonfunctional, knn_lw, na.action = na.omit, zero.policy = TRUE)\n\n\n\n\nPress to toggle code\nhead(localMI_fun, n = 5)\n\n\n          Ii         E.Ii      Var.Ii       Z.Ii Pr(z != E(Ii))\n1  2.5100432 -0.001328196  1.01853344  2.4884177   1.283129e-02\n2  2.5545352 -0.001431708  1.09789794  2.4393507   1.471368e-02\n3 33.9550743 -0.043926357 33.50573077  5.8736303   4.263537e-09\n4 -0.6153427 -0.001593282  1.22177539 -0.5552588   5.787177e-01\n5  0.2676861 -0.000065655  0.05035578  1.1931846   2.327971e-01\n\n\n\n\nPress to toggle code\nhead(localMI_nonfun, n = 5)\n\n\n         Ii         E.Ii    Var.Ii     Z.Ii Pr(z != E(Ii))\n1  5.407157 -0.006784813  5.199415 2.374304   1.758207e-02\n2  4.964822 -0.004189178  3.211341 2.772853   5.556728e-03\n3 23.376412 -0.030241154 23.106738 4.869339   1.119723e-06\n4  1.735812 -0.013188412 10.098598 0.550376   5.820615e-01\n5  7.139931 -0.006117971  4.688784 3.300166   9.662752e-04\n\n\n\n\nMapping local Moran‚Äôs I values and p-values for 'pct_functional'\nThe code chunk below save the local Moran values for 'pct_functional' to our main spatial dataframe ‚Äònga_wp_final‚Äô using the function cbind() which combines two dataframes.\n\n\nPress to toggle code\nnga_wp_final.localMI_fun <- cbind(nga_wp_final,localMI_fun) %>% rename(Pr.Ii = Pr.z....E.Ii..)\n\n\nUsing the different tmap functions, we can map the local Moran‚Äôs I values and p-values for 'pct_functional' using the code chunk below.\n\n\nPress to toggle code\nlocalMI.map <- tm_shape(nga_wp_final.localMI_fun) + tm_fill(col = \"Ii\", style = \"pretty\", palette = \"PiYG\", title = \"local Moran's I\") + tm_borders(alpha = 0.5)+ tm_layout(main.title = \"Functional Water Point (%)\", main.title.size = 0.9, title = \"Local Moran's I values\", title.size = 0.7, legend.width = 0.3, legend.height = 0.25)\n\npvalue.map <- tm_shape(nga_wp_final.localMI_fun) +\n  tm_fill(col = \"Pr.Ii\", breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),palette=\"-RdPu\", title = \"p-values\") + tm_borders(alpha = 0.5)+ tm_layout(main.title = \"Functional Water Point (%)\", main.title.size = 0.9, title = \"Local Moran's I p-values\", title.size = 0.7, legend.width = 0.3, legend.height = 0.25)\n\ntmap_arrange(localMI.map, pvalue.map, ncol=2)\n\n\n\n\n\n\n\nMapping local Moran‚Äôs I values and p-values for 'pct_nonfunctional'\nSimilar code chunks are used for 'pct_nonfunctional' as shown below.\n\n\nPress to toggle code\nnga_wp_final.localMI_nonfun <- cbind(nga_wp_final,localMI_nonfun) %>% rename(Pr.Ii = Pr.z....E.Ii..)\n\n\n\n\nPress to toggle code\nlocalMI.map <- tm_shape(nga_wp_final.localMI_nonfun) + tm_fill(col = \"Ii\", style = \"pretty\", palette = \"PiYG\", title = \"local Moran's I\") + tm_borders(alpha = 0.5)+ tm_layout(main.title = \"Non-Functional Water Point (%)\", main.title.size = 0.9, title = \"Local Moran's I values\", title.size = 0.7, legend.width = 0.3, legend.height = 0.25)\n\npvalue.map <- tm_shape(nga_wp_final.localMI_nonfun) +\n  tm_fill(col = \"Pr.Ii\", breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),palette=\"-RdPu\", title = \"p-values\") + tm_borders(alpha = 0.5)+ tm_layout(main.title = \"Non-Functional Water Point (%)\", main.title.size = 0.9, title = \"Local Moran's I p-values\", title.size = 0.7, legend.width = 0.3, legend.height = 0.25)\n\ntmap_arrange(localMI.map, pvalue.map, ncol=2)\n\n\n\n\n\n\n\nMapping local Moran‚Äôs I values for 'pct_functional' and 'pct_nonfunctional' with p-value > 0.05\nIt‚Äôs a bit difficult to clearly compare the local Moran‚Äôs I values and p-values based on the chloropleth mapping. By using nga_wp_final.localMI_fun[nga_wp_final.localMI_fun$Pr.Ii < 0.05,] as the argument of tm_shape() , we are telling R to color the features that have p-values greater than 0.05. This means these are the LGAs with local Moran I values for 'pct_functional' or 'pct_nonfunctional' that are statistically significant.\n\n\nPress to toggle code\nlocalMI_fun.map <- tm_shape(nga_wp_final.localMI_fun)+ tm_fill(\"white\") + tm_borders(\"grey\", lwd = 0.5, alpha = 0.5) + tm_shape(nga_wp_final.localMI_fun[nga_wp_final.localMI_fun$Pr.Ii < 0.05,]) + tm_fill(col = \"Ii\", style = \"pretty\",  title = \"local Moran's I\", palette = \"RdPu\") + tm_borders(alpha = 0.5) + tm_layout(main.title = \"Functional Water Point (%)\", main.title.size = 0.9, title = \"Local Moran's I values\", title.size = 0.7, legend.width = 0.3, legend.height = 0.25)\n\nlocalMI_nonfun.map <-  tm_shape(nga_wp_final.localMI_nonfun)+ tm_fill(\"white\") + tm_borders(\"grey\", lwd = 0.5, alpha = 0.5) + tm_shape(nga_wp_final.localMI_nonfun[nga_wp_final.localMI_nonfun$Pr.Ii < 0.05,]) + tm_fill(col = \"Ii\", style = \"pretty\",title = \"local Moran's I\", palette = \"RdPu\") + tm_borders(alpha = 0.5) + tm_layout(main.title = \"Non-Functional Water Point (%)\", main.title.size = 0.9, title = \"Local Moran's I values\", title.size = 0.7, legend.width = 0.3, legend.height = 0.25)\n\ntmap_arrange(localMI_fun.map, localMI_nonfun.map, ncol=2)\n\n\n\n\n\n\n\nCreating a LISA cluster map for 'pct_functional'\n\nCreating a Moran scatterplot for 'pct_functional'\n\n\nPress to toggle code\nnga_wp_final$Z.pct_functional <- scale(nga_wp_final$pct_functional) %>% as.vector \n\nmscat_fun <- moran.plot(nga_wp_final$Z.pct_functional, knn_lw,labels=as.character(nga_wp_final$shapeName), xlab = \"Functional Water Points (%)\", ylab = \"Spatially Lagged Functional Water Points (%)\")\n\n\n\n\n\n\n\nCreating a Moran scatterplot for 'pct_nonfunctional'\n\n\nPress to toggle code\nnga_wp_final$Z.pct_nonfunctional <- scale(nga_wp_final$pct_nonfunctional) %>% as.vector \n\nmscat_nonfun <- moran.plot(nga_wp_final$Z.pct_nonfunctional, knn_lw,labels=as.character(nga_wp_final$shapeName), xlab = \"Functional Water Points (%)\", ylab = \"Spatially Lagged Functional Water Points (%)\")\n\n\n\n\n\n\n\nPreparing LISA map classes for 'pct_functional' and 'pct_nonfunctional'\nThe code chunk below prepares the LISA cluster map. The function lag.listw() uses the first argument, the spatial weights matrix, to create a spatially lagged variable of the second argument. The next code snippet following centers the lagged variable to its mean using \\(x-\\bar{x}\\) which is basically the deviation.\nThe four lines of quadrant code define the low-low (1), low-high (2), high-low (3) and high-high (4) categories. The fifth line after places non-significant Moran in the category 0.\n\n\nPress to toggle code\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI_fun))\nsignif <- 0.05 \n\n# Functional \nnga_wp_final$lag_pct_functional <- lag.listw(knn_lw, nga_wp_final$pct_functional)\n\nDV <- nga_wp_final$lag_pct_functional - mean(nga_wp_final$lag_pct_functional)  \n\nLM_I <- localMI_fun[,1]   \n\nquadrant[DV <0 & LM_I>0] <- 1\nquadrant[DV >0 & LM_I<0] <- 2\nquadrant[DV <0 & LM_I<0] <- 3  \nquadrant[DV >0 & LM_I>0] <- 4    \nquadrant[localMI_fun[,5]>signif] <- 0\n\nnga_wp_final.localMI_fun$quadrant <- quadrant\n\n# Non-Functional\n\nnga_wp_final$lag_pct_nonfunctional <- lag.listw(knn_lw, nga_wp_final$pct_nonfunctional)\n\nDV <- nga_wp_final$lag_pct_nonfunctional - mean(nga_wp_final$lag_pct_nonfunctional)  \n\nLM_I <- localMI_nonfun[,1]   \n\nquadrant[DV <0 & LM_I>0] <- 1\nquadrant[DV >0 & LM_I<0] <- 2\nquadrant[DV <0 & LM_I<0] <- 3  \nquadrant[DV >0 & LM_I>0] <- 4    \nquadrant[localMI_fun[,5]>signif] <- 0\n\nnga_wp_final.localMI_nonfun$quadrant <- quadrant\n\n\n\n\nPlotting the LISA for 'pct_functional' and 'pct_nonfunctional'\n\n\nPress to toggle code\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nlisa_fun.map <- tm_shape(nga_wp_final.localMI_fun) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) + tm_layout(main.title = \"Functional Water Points(%)\", main.title.size = 0.8)\n\nlisa_nonfun.map <- tm_shape(nga_wp_final.localMI_nonfun) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)+ tm_layout(main.title = \"Non-Functional Water Points (%)\", main.title.size = 0.8)\n  \ntmap_arrange(lisa_fun.map, lisa_nonfun.map, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\n\n\nFIRST IMPRESSIONS!\n\n\n\nThe following observations were made from the plots above:\n\nWhile the Northen side of Nigeria seems to have more functional water points, there are a few LGAs that have L-H Functional/H-L Non-Functional values meaning they are outliers. The H-H Functional/L-L Non-Functional LGAs may be able to extend services to their outlier neighbors to get the water points functioning again.\nThe Eastern side of Nigeria is L-L Functional / L-L Non-Functional because these are the areas with unknown records.\nThe Southern area of Nigeria seems to have more L-L Functional/H-H Non-Functional LGAs with a few H-L Functional outliers, particularly in the Southeastern area. Having more non-functional water points could be because of the current politcal climate in the area. There are a small number of LGAs in the edge of the Southern area that are H-H Functional/L-L Non-Functional. They seem to belong to the ‚ÄúRivers‚Äù state, which is full of different freshwater sources.\n\nThe image below was used as reference for regions."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#hot-and-cold-spots-analysis",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#hot-and-cold-spots-analysis",
    "title": "Take-home Exercise 1: Geospatial Analytics for Social Good",
    "section": "Hot and Cold Spots Analysis",
    "text": "Hot and Cold Spots Analysis\nUsing Getis and Ord‚Äôs G-statistics, determines statistically significant hot-spots in areas of high values that are also surrounded by areas with high values.\n\nComputing \\(G_i\\) statistics\nThe function localG() generates the \\(G_i\\) statistic using the variable and the spatial weights matrix. By using the as.matrix() function we can convert the list object into a dataframe that can be binded to our main dataframe ‚Äònga_wp_final‚Äô.\n\n\nPress to toggle code\n#Functional\ngi.adaptive <- localG(nga_wp_final$pct_functional, knn_lw)\nnga_wp_final.gi_fun <- cbind(nga_wp_final, as.matrix(gi.adaptive)) %>% rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n#Non-Functional\ngi.adaptive <- localG(nga_wp_final$pct_nonfunctional, knn_lw)\nnga_wp_final.gi_nonfun <- cbind(nga_wp_final, as.matrix(gi.adaptive)) %>% rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\n\nMapping \\(G_i\\) statistics for 'pct_functional'\n\n\nPress to toggle code\npct_functional<- qtm(nga_wp_final, \"pct_functional\", fill.palette = \"RdPu\", fill.title = \"Percentage\") + tm_layout(main.title = \"Functional (%)\", main.title.size = 1, legend.height = 0.6)\n\nGimap_fun <- tm_shape(nga_wp_final.gi_fun) + \n  tm_fill(col = \"gstat_adaptive\", style = \"pretty\", palette=\"-RdBu\", title = \"local Gi\") + tm_borders(alpha = 0.5) + tm_layout(main.title = \"Functional Gi Map\", main.title.size = 1, legend.height = 0.6)\n\npct_nonfunctional<- qtm(nga_wp_final, \"pct_nonfunctional\", fill.palette = \"RdPu\", fill.title = \"Percentage\") + tm_layout(main.title = \"Non-Functional (%)\", main.title.size = 1, legend.height = 0.6)\n\nGimap_nonfun <- tm_shape(nga_wp_final.gi_nonfun) + \n  tm_fill(col = \"gstat_adaptive\", style = \"pretty\", palette=\"-RdBu\", title = \"local Gi\") + tm_borders(alpha = 0.5) + tm_layout(main.title = \"Non-Functional Gi Map\", main.title.size = 1, legend.height = 0.6)\n\ntmap_arrange(pct_functional, Gimap_fun, pct_nonfunctional, Gimap_nonfun, ncol=2, nrow = 2, widths = c(0.5,0.5,0.5,0.5))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "",
    "text": "Image of Nigerian children at water point courtesy of Dataphyte\n\n\n\n\nIn 2018, a paper was published by Andres, et al.¬†discussing one big important question:\n\nWhy are so many water points in Nigeria non-functional?\n\nThey observed that 27% of water points tend to fail within the first year of its construction and 40% end up failing after around 8-10 years. These number are clearly not sustainable. The paper cites location as a major factor, specifying that urban areas tend to have non-functional water point possibly due to overcrowding. Because of this the north side of Nigeria has more functional water points than the South; a finding that we also observed in Take-home Exercise 1. Another factor is the water technology used since motorized pumps are more likely to fail than hand pumps.\nIn the previous exercise, we observed the patterns in functionality using local and global measures of spatial autocorrelation. Now that we established spatial relationships, we can proceed to look further and group these local government areas based on several factors such as the percentage of functional/non-functional water points, percentage of rural areas, percentage of hand pumps, percentage of over-utilized water points, and more. From this, we can hopefully build on the paper‚Äôs conclusions and find more insights on the water point situation for different local government areas in Nigeria.\n\n\n\nThe process of creating regions is called regionalization. It‚Äôs a special kind of clustering where features are grouped by both spatial contiguity and their similarity in different attributes. We can also look at it as the usual clustering except with geographical constraints.\n\n\n\nAs a continuation of Take-home Exercise 1 and an application of Chapter 5 of ‚ÄúR for Geospatial Data Science and Analytics‚Äù, this is my submission for Take-home Exercise 2. The following objectives were accomplished in this exercise:\n\nAcquiring, importing and wrangling geospatial and aspatial data\nDelineating water point measures functional regions by using conventional hierarchical clustering and spatially constrained clustering algorithms\nPlotting to show the water points measures derived by using appropriate statistical graphics and choropleth mapping technique"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#acquiring-the-data",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#acquiring-the-data",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Acquiring the Data",
    "text": "Acquiring the Data\nSimilar to the first take-home exercise, there are two important datasets to access which will be expounded upon below.\n\nAdministrative Boundaries of Nigeria\nFirst we have the Level-2 Administrative Boundary (A.K.A. Local Government Areas) of Nigeria, as sourced from The Humanitarian Exchange Portal. The screenshot attached shows where to acquire the dataset. After downloading, there should be a ZIP file with multiple files. We are using all shape data named ‚Äònga_admbnda_adm2_osgof_20190417‚Äô, which will be renamed to ‚Äònga_adm2‚Äô for simplicity.\n\n\n\nScreenshot of Nigeria‚Äôs ADM2 boundary polygon features GIS data source from The Humanitarian Exchange Portal\n\n\n\n\nWater Point Data\nTo be able to analyze the water points of different areas, we‚Äôll need the data from Water Point Data Exchange (WPdx) Repository. There are two versions, WPdx-Basic and WPdx+. For this take-home exercise, we are making use of WPdx+.\n\n\n\nScreenshot of Water Point Data Exchange Plus data source from https://data.waterpointdata.org/\n\n\nThe site allows us to export the data in different file formats. For this exercise, I downloaded the Shapefile for familiarity. To simplify the filename, all related files were renamed to ‚Äúgeo_export‚Äù."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#loading-the-packages",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#loading-the-packages",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Loading the Packages",
    "text": "Loading the Packages\nThe code chunk below loads the necessary packages for this exercise.\n\n\nPress to toggle code\npacman::p_load(rgdal, spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, tidyverse, GGally)\n\n\n\n\n\n\n\n\nüíª CODE REVIEW!\n\n\n\nWhat is the purpose of each package?\n\nsf - support for simple features, a standardized way to encode spatial vector data\ntidyverse - core packages for data analyses\ntmap - used for thematic plotting of maps\nspedep - a library for creating spacial weights\ncorrplot - used for visualization of the correlation matrix\nggpubr - provides easy-to-use functions for creating publication ready plots built on ggplot2\nheatmaply - used to make interactive heatmaps that allow the inspection of specific value by hovering the mouse over a cell\ncluster - contains functions for cluster analysis\nNbClust - used to figure out the best clustering scheme from the different results obtained by varying all combinations of number of clusters, distance measures, and clustering methods\nfactoextra - easy-to-use functions to extract and visualize the output of multivariate data analyses\nrgdal - the GDAL in 'rgdal' stands for 'Geospatial Data Abstraction Library' which is a translator library for raster and vector geospatial data format; it also has projection/transformation operations from the 'PROJ' library\n\nThis library will be retired by the end of 2023!\n\nGGally- an extension of ggplot2 that adds several functions to reduce the complexity of combining geoms with transformed data\nClustGeo - has a special function in particular is hclustgeo() uses a Ward-like hierarchical clustering algorithm while taking into account geographical constraints"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#importing-the-data",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#importing-the-data",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Importing the Data",
    "text": "Importing the Data\n\nImporting the LGA boundaries of Nigeria\nUsing the st_read() function of the sf package, the code chunk below creates a simple features data frame from the nga-adm2 shapefiles.\n\n\nPress to toggle code\nnga_bounds <- st_read(dsn = \"data\", layer = \"nga_adm2\", crs = 4326)\n\n\n\n\n\n\n\nNigeria has 774 local government areas (LGAs). The terms ‚ÄúLGA‚Äù, ‚Äúpolygon‚Äù, and ‚Äúfeature‚Äù will be used interchangeably from this point forward in this take-home exercise.\n\n\nImporting the water point data of Nigeria\nSimilarly above, we once again use st_read() to import the geo_export shapefile. However, this time we need to use the filter() function to make sure that we only extract the data related to Nigeria. The code snippet filter(clean_coun == \"Nigeria\") does just this, where ‚Äòclean_coun‚Äô is the column from the data table referring to the country name and == asks for the records set as ‚ÄúNigeria‚Äù.\n\n\nPress to toggle code\nnga_wp <- st_read(dsn = \"data\", layer = \"geo_export\", crs = 4326) %>% filter(clean_coun == \"Nigeria\")\n\n\n\n\n\n\n\nWe end up with a data table containing 95,008 records and 73 variables. The geometry type is POINT, meaning each record is a point relative to the coordinate system. The records refer to different water points in Nigeria with different descriptions such as status, water source, usage capacity, etc."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#duplicate-adm2_en",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#duplicate-adm2_en",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Duplicate 'ADM2_EN'",
    "text": "Duplicate 'ADM2_EN'\nBefore proceeding with fixing our variables, let‚Äôs first take a look at our boundary data. The column 'ADM2_EN' refers to the name of the LGA. It‚Äôs not uncommon for LGAs to have similar names but to be located in different regions. However, for this exercise, we will need to be able to differentiate from the 'ADM2_EN' value itself. Let‚Äôs check to see first if Nigera has an duplicate LGAs.\nThe following process was inspired from Ong Jordan‚Äôs Take Home Exercise 1. In the code chunk below, the function order() arranges the data alphabetically based on the 'ADM2_EN'. The function 'duplicated()' returns a logical vector (containing TRUE/FALSE) indicating which elements are duplicates. Finally, the code snippet nga_bounds$ADM2_EN[duplicated(nga_bounds$ADM2_EN)] returns the list of all duplicated names, giving us the list 'duplicate_area'.\n\n\nPress to toggle code\nnga_bounds <- (nga_bounds[order(nga_bounds$ADM2_EN), ])\n\nduplicate_area <- nga_bounds$ADM2_EN[duplicated(nga_bounds$ADM2_EN)]\n\nduplicate_area\n\n\n\n\n\n\n\nIn Jordan‚Äôs process, he googles the state of each LGA and manually changes the data on the sf data frame. Fortunately, since our boundary data provides the state as well, we can append the state given by the variable 'ADM1_EN' to the LGA given by the variable 'ADM2_EN' in order to differentiate the ones with similar names.\nThe code chunk below uses which() to get the list of row numbers or indices that have 'ADM2_EN' values found in our ‚Äôduplicate_area' list. The next segment shows a for loop that concatenates 'ADM2_EN' and 'ADM1_EN' using the function paste().\n\n\nPress to toggle code\nduplicate_rows <- which(nga_bounds$ADM2_EN %in% duplicate_area)\n\nfor(x in duplicate_rows){\n  nga_bounds$ADM2_EN[x] <- paste(nga_bounds$ADM2_EN[x], \" (\", nga_bounds$ADM1_EN[x], \")\", sep = \"\")\n}\n\n\nUsing the code chunk below we can verify that the 'ADM2_EN' names have been modified.\n\n\nPress to toggle code\nnga_bounds$ADM2_EN[duplicate_rows]\n\n\n\n\n\n\n\nThe code chunk below also verifies that there are no more duplicates in the column 'ADM2_EN' because the only returned value from duplicated() is FALSE.\n\n\nPress to toggle code\nunique(duplicated(nga_bounds$ADM2_EN))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#renaming-column-names",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#renaming-column-names",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Renaming Column Names",
    "text": "Renaming Column Names\nGoing back to our water point data, we know that the columns 'status_cle', 'X_water_tec', 'usage_cap', 'pressure' and 'is_urban' are significant to our analysis. To make referring to these variables easier, we rename some of them using the code chunk below:\n\n\nPress to toggle code\nnga_wp <- rename (nga_wp, \"status_cat\" = \"status_cle\",\n                  \"water_tech_cat\" = \"X_water_tec\",\n                  \"press_score\" = \"pressure\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#removing-nas",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#removing-nas",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Removing NAs",
    "text": "Removing NAs\n\nChecking for NA values\nGiven the significance of the columns 'status_cat', 'water_tech_cat', 'usage_cap', 'press_score' and 'is_urban', we need to make sure that they do not contian NA values.\nThe code chunk below uses sum() to add up the TRUE values from the logical vector produced by is.na() which returns true for rows with an NA value in that particular column. ‚ÄòNA_vals‚Äô is simply a vector of all the results.\n\n\nPress to toggle code\nNA_vals <- c(sum(is.na(nga_wp$status_cat)),\n                sum(is.na(nga_wp$water_tech_cat)), \n                sum(is.na(nga_wp$usage_cap)),\n                sum(is.na(nga_wp$press_score)),\n                sum(is.na(nga_wp$is_urban)))\n\nNA_vals <- setNames(NA_vals, c(\"status_cat\",\n                               \"water_tech_cat\",\n                               \"usage_cap\", \n                               \"press_score\", \n                               \"is_urban\"))\nNA_vals\n\n\n\n\n\n\n\nBased on the result above, we can see that 'status_cat' , 'water_tech_cat' and 'press_score' have 10,656, 10,055 and 6,879 NA values respectively. Fortunately 'usage_cap' and 'is_urban' have no NA values.\n\n\n\n\n\n\nüíª CODE REVIEW!\n\n\n\nWhile not relevant to the analytical process, the function setNames() is useful for visualizing values in a vector or list. It is used to set the name (or index value) of an object. For the code chunk above, I used it to easily show the pertaining number of NA values to the corresponding column name.\n\n\n\n\nReplacing the NA values\nGiven that both 'status_cat' and 'water_tech_cat' are categorical values, we can easily add a new category called ‚ÄúUnknown‚Äù which will replace all the NA values.\n\n\nPress to toggle code\nnga_wp <- nga_wp %>% mutate(status_cat = replace_na(status_cat, \"Unknown\")) %>% \n                            mutate(water_tech_cat = replace_na(water_tech_cat, \"Unknown\"))\n\n\nFor 'press_score', since this is a numerical value, we will set all the NA values to 0. While it seems that doing this would skew the data, it won‚Äôt affect the output as much later when we derive our variables.\n\n\nPress to toggle code\nnga_wp <- nga_wp %>% mutate(press_score = replace_na(press_score, 0))\n\n\nRunning the code chunk from earlier to check for NA values, we find that we have no more NA values.\n\n\nPress to toggle code\nNA_vals <- c(sum(is.na(nga_wp$status_cat)),\n                sum(is.na(nga_wp$water_tech_cat)), \n                sum(is.na(nga_wp$usage_cap)),\n                sum(is.na(nga_wp$press_score)),\n                sum(is.na(nga_wp$is_urban)))\n\nNA_vals <- setNames(NA_vals, c(\"status_cat\",\n                               \"water_tech_cat\",\n                               \"usage_cap\", \n                               \"press_score\", \n                               \"is_urban\"))\nNA_vals"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#regionalizing-the-data",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#regionalizing-the-data",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Regionalizing the Data",
    "text": "Regionalizing the Data\nSo we have the individual water points, but how do we translate it in such a way that we can compare it for each LGA?\n\nUnderstanding our variables once again\nSince 'status_cat' , 'water_tech_cat', and 'is_urban' are nominal, we can use unique() to look at the different category values of each.\n\n\nPress to toggle code\nunique_vals <- list(unique(nga_wp$status_cat),\n                unique(nga_wp$water_tech_cat), \n                unique(nga_wp$is_urban))\n\nunique_vals <- setNames(unique_vals, c(\"status_cat\",\n                       \"water_tech_cat\",\n                       \"is_urban\"))\nunique_vals\n\n\n\n\n\n\n\nThe types of water technology used by Nigeria are ‚ÄúTapstand‚Äù, ‚ÄúMechanized Pump‚Äù, ‚ÄúHand Pump‚Äù and ‚ÄúRope Bucket‚Äù as shown by the 'water_tech_cat' column. Since 'is_urban' is boolean, naturally the possible values are ‚ÄúTrue‚Äù and ‚ÄúFalse‚Äù.\nSimilarly to the first take-home exercise, the output shows that there are 7 different 'status_cat' values. The distribution of the statuses is shown below.\n\n\nPress to toggle code\nggplot(data=nga_wp, aes(x = status_cat)) +\n      geom_bar(fill = \"#e3879e\") + \n      geom_text(stat = 'count', \n                aes(label=..count..), \n                vjust = -0.1, color = \"#cb6a82\", \n                size = 5) +\n      labs(title = \"Distribution of Statuses of Water Points in Nigeria\",\n           x = \"Status\",\n           y = \"Count\")+\n      theme(axis.text.x = element_text(angle = 90, \n                                       vjust = 0.5, \n                                       hjust = 1,\n                                       size = 15),\n            axis.title = element_text(size = 15),\n            plot.title = element_text(size = 20))\n\n\n\n\n\n\n\nThe three big groups are ‚ÄúFunctional‚Äù, ‚ÄúNon-Functional‚Äù and ‚ÄúUnknown‚Äù. Looking at the other status categories, we can see that they fall under the same status umbrella of either ‚ÄúFunctional‚Äù or ‚ÄúNon-Functional‚Äù; they just contain extra information. We can instead group these minor statuses with their corresponding major category from the three big largest count groups. The code chunk below groups and filters all ‚ÄúFunctional‚Äù, ‚ÄúNon-Functional‚Äù and ‚ÄúUnknown‚Äù water points.\n\n\nPress to toggle code\nwpt_functional <- nga_wp %>% filter(status_cat %in% c(\"Functional\", \"Functional but not in use\", \"Functional but needs repair\"))\n\nwpt_nonfunctional <- nga_wp %>% filter(status_cat %in% c(\"Abandoned/Decommissioned\", \"Abandoned\", \"Non-Functional\", \"Non functional due to dry season\", \"Non-Functional due to dry season\"))\n\nwpt_unknown <- nga_wp %>% filter(status_cat == \"Unknown\")\n\n\nNow that‚Äôs done, we have variables that weren‚Äôt explored in Take-home Exercise 1. Let‚Äôs take a look at the distribution of 'water_tech_cat'.\n\n\nPress to toggle code\nggplot(data=nga_wp, aes(x = water_tech_cat)) +\n      geom_bar(fill = \"#e3879e\") + \n      geom_text(stat = 'count', \n                aes(label=..count..), \n                vjust = -0.2, color = \"#cb6a82\", \n                size = 5) +\n      labs(title = \"Distribution of Water Technology in Nigeria\",\n           x = \"Water Technology\",\n           y = \"Count\")+\n      theme(axis.text = element_text(size = 15),\n            axis.title = element_text(size = 15),\n            plot.title = element_text(size = 20))\n\n\n\n\n\n\n\nFrom the graph above, we see that the water technology ‚ÄúHand Pump‚Äù has the larges count and is the majority water technology since it is around 62% of all water points. Because of that, let‚Äôs filter the water points that make use of hand pumps. Later on, we‚Äôll use this to get the percentage of hand pumps in each LGA.\n\n\nPress to toggle code\nwpt_handpump <- nga_wp %>% filter(water_tech_cat %in% c(\"Hand Pump\"))\n\n\n\n\n\n\n\n\nüåê JUST SO YOU KNOW...\n\n\n\n\n\n\n\n\nThis is a hand pump. Water flows through the opening by manually operating the rod by hand. It brings water from underground to the surface, and so it opens access to deeper groundwater that is often not polluted and also improves the safety of a well by protecting the water source from contaminated buckets. It‚Äôs popular in rural area for being economical and simple.\n\n\nNext we have 'is_urban' which basically dictates whether the water point is located in an urban ('is_urban' == ‚ÄúTrue‚Äù) or rural area ('is_urban' == ‚ÄúFalse‚Äù). The distribution is shown below.\n\n\nPress to toggle code\nggplot(data=nga_wp, aes(x = is_urban)) +\n      geom_bar(fill = \"#e3879e\") + \n      geom_text(stat = 'count', \n                aes(label=..count..), \n                vjust = -0.2, color = \"#cb6a82\", \n                size = 5) +\n      labs(title = \"Distribution Urban or Rural Water Points in Nigeria\",\n           x = \"Area\",\n           y = \"Count\")+\n      theme(axis.text = element_text(size = 15),\n            axis.title = element_text(size = 15),\n            plot.title = element_text(size = 20))+\n      scale_x_discrete(labels= c(\"Rural\", \"Urban\"))\n\n\n\n\n\n\n\nBased on the distribution above, we see that most of the water points are found in rural areas. The code chunk below filters the water points that are found in rural areas.\n\n\nPress to toggle code\nwpt_rural <- nga_wp %>% filter(is_urban == \"False\")\n\n\nMoving on, we have the two variables 'usage_cap' and 'press_score' which have numerical values. While usage capacity has numerical values, if you take a look at the distribution below, you‚Äôll notice that there are four values or categories of usage capacity. Each category is basically the number of recommended max users of a water point.\n\n\nPress to toggle code\nggplot(data=nga_wp, aes(x = reorder(as.character(usage_cap), usage_cap))) +\n      geom_bar(fill = \"#e3879e\") + \n      geom_text(stat = 'count', \n                aes(label=..count..), \n                vjust = -0.2, color = \"#cb6a82\", \n                size = 5) +\n      labs(title = \"Distribution of Usage Capacity in Nigeria\",\n           x = \"Usage Capacity (Users)\",\n           y = \"Count\")+\n      theme(axis.text = element_text(size = 15),\n            axis.title = element_text(size = 15),\n            plot.title = element_text(size = 20))\n\n\n\n\n\n\n\nThe distribution above shows that most water points have a usage capacity of 300. However, since 1000 is the highest possible number of theoretical maximum users, it is the most ideal. We then divide the water points between those with usage capacity of 1000 and those with below 1000 using the code chunk below.\n\n\nPress to toggle code\nwpt_usagecap1000 <- nga_wp %>% filter(usage_cap >= 1000)\n\nwpt_usagecaplt1000 <- nga_wp %>% filter(usage_cap < 1000)\n\n\nFinally we have 'press_score' which is a continuous variable. The distribution is shown in the histogram below.\n\n\nPress to toggle code\nggplot(data=nga_wp, aes(x = press_score)) +\n      geom_histogram(fill = \"#e3879e\", bins = 100) +\n      labs(title = \"Distribution of Pressure Score in Nigeria\",\n           x = \"Pressure Score\",\n           y = \"Count\") + \n      \n      theme(axis.text = element_text(size = 15),\n            axis.title = element_text(size = 15),\n            plot.title = element_text(size = 20))\n\n\n\n\n\n\n\nBecause of the range of values, the distribution can‚Äôt be properly visualized in the histogram above. Instead, given the context of the variable, it may be better to separate the values into categories. Since we know that the pressure score pertains to the ratio of the population assigned to the water point over the theoretical maximum users, we can define having a pressure score above 1 or 100% as a water point that is overused or under a lot of use pressure. A new distribution using a bar graph can be found below.\n\n\n\n\n\nPress to toggle code\nggplot(data=nga_wp, aes(x = press_score_1)) +\n      geom_bar(fill = \"#e3879e\") +\n      labs(title = \"Distribution of Pressure Score in Nigeria\",\n           x = \"Pressure Score\",\n           y = \"Count\") + \n      geom_text(stat = 'count', \n                aes(label=..count..), \n                vjust = -0.1, color = \"#cb6a82\", \n                size = 5) +\n      theme(axis.text = element_text(size = 15),\n            axis.title = element_text(size = 15),\n            plot.title = element_text(size = 20))+\n      scale_x_discrete(labels= c(\"<= 100%\", \"> 100%\"))\n\n\n\n\n\n\n\nThe distribution of whether water points overly maximized or underutilized seems to be relatively even. We can then filter the water points with 'press_score' greater than 1 using the code chunk below.\n\n\nPress to toggle code\nwpt_pressured <- nga_wp %>% filter(press_score > 1) \n\n\n\n\nPerforming point-in-polygon count and deriving variables\nNow that we‚Äôve filtered certain water points, we can perform point-in-polygon count to regionalize our water point data and create variables that describe the state of water points in each LGA.\nSince we know the individual water points (as POINT data), we can see where they overlap with the polygons (LGAs) to determine regional data. The function st_intersects() returns true if two geometries intersect, meaning if the water point is found within the polygon boundary of an LGA, it will return true. The function lengths() gives the number of true values (or count) returned from st_intersects().\nWith that, we use the filtered sf data frame objects we made in the previous section to get the number of the water points that fulfill the variable for each LGA. As shown in the code chunk below, we add new columns using mutate(). Building on our boundary data ‚Äònga_bounds‚Äô, we create our main sf data frame ‚Äònga_wp_final‚Äô.\n\n\nPress to toggle code\nnga_wp_final <- nga_bounds %>% \n  # Total Number of Water Points in LGA\n  mutate(`total_wpt` = lengths(st_intersects(nga_bounds, nga_wp))) %>% \n  # Total Number of Functional Water Points in LGA\n  mutate(`wpt_functional` = lengths(st_intersects(nga_bounds, wpt_functional))) %>% \n  # Total Number of Non-Functional Water Points in LGA\n  mutate(`wpt_nonfunctional` = lengths(st_intersects(nga_bounds, wpt_nonfunctional))) %>% \n  # Total Number of Unknown Water Points in LGA\n  mutate(`wpt_unknown` = lengths(st_intersects(nga_bounds, wpt_unknown))) %>% \n  # Total Number of Hand Pumps in  LGA \n  mutate(`wpt_handpump` = lengths(st_intersects(nga_bounds, wpt_handpump))) %>% \n  # Total Number of Water Points with 1000 Usage Capacity in LGA\n  mutate(`wpt_usagecap1000` = lengths(st_intersects(nga_bounds, wpt_usagecap1000))) %>% \n  # Total Number of Water Points with Usage Capacity < 1000 in LGA \n  mutate(`wpt_usagecaplt1000` = lengths(st_intersects(nga_bounds, wpt_usagecaplt1000))) %>% \n  # Total Number of Water Points in Rural Areas\n  mutate(`wpt_rural` = lengths(st_intersects(nga_bounds, wpt_rural))) %>%\n  # Total Number of Over-Utilized Water Points in LGA\n  mutate(`wpt_pressured` = lengths(st_intersects(nga_bounds, wpt_pressured)))\n\n\nThe figure below shows the new columns showing count values produced by intersecting the water point points and LGA polygons.\n\n\n\n\n\nNot all LGAs are made equal. It wouldn‚Äôt make sense to compare the number of water points in a smaller area to a bigger area because it‚Äôs possible that larger land area would contribute to having more water points. To give a better analysis of the collective water point characteristics per LGA, we can get the percentage or ratio using the new column variables we just added and the total water points in each LGA.\n\n\nPress to toggle code\nnga_wp_final <- nga_wp_final %>% \n  # % of Functional Water Points in the LGA\n  mutate(`pct_functional` = `wpt_functional`/`total_wpt`) %>% \n  # % of Non-Functional Water Points in the LGA\n  mutate(`pct_nonfunctional` = `wpt_nonfunctional`/`total_wpt`) %>%\n  # % of Hand Pumps in the LGA\n  mutate(`pct_handpump` = `wpt_handpump`/`total_wpt`) %>%\n  # % of Usage Capacity = 1000 Water Points \n  mutate(`pct_usagecap1000` = `wpt_usagecap1000`/`total_wpt`) %>%\n  # % of Usage Capacity < 1000 Water Points\n  mutate(`pct_usagecaplt1000` = `wpt_usagecaplt1000`/`total_wpt`) %>%\n  # % of Water Points in Rural Areas\n  mutate(`pct_rural` = `wpt_rural`/`total_wpt`) %>% \n  # % of OVer-pressured Water Points \n  mutate(`pct_pressured` = `wpt_pressured`/`total_wpt`)\n\n\n\n\nRemoving LGAs with no water points\nThe code chunk below checks if there are any NA values in our newly derived values using is.na() and rowSums() .\n\n\nPress to toggle code\npcts <- c(\"pct_functional\", \n          \"pct_nonfunctional\", \n          \"pct_handpump\", \n          \"pct_usagecap1000\", \n          \"pct_usagecaplt1000\",\n          \"pct_rural\",\n          \"pct_pressured\")\n\nnrow(nga_wp_final[rowSums(is.na(nga_wp_final[pcts])) > 0, ])\n\n\n\n\n\n\n\nThe result above shows that 13 records have NA values in our newly derived percentage variables. How is this possible? Even if we removed NA values by replacing them, we created new NA values because of zero division. Zero division happened because there are LGA polygons without any recorded water points that intersected with it.\nThe code chunk below extracts the rows numbers of LGAs without any recorded water points as stated by nga_wp_final$total_wpt == 0.\n\n\nPress to toggle code\nno_wp <- which(nga_wp_final$total_wpt == 0)\n\n\n\n\n\n\n\nThe code chunk below removes the rows (LGAs with no recorded water points) from our main sf data frame.\n\n\nPress to toggle code\nnga_wp_final <- nga_wp_final[!(row.names(nga_wp_final) %in% as.vector(no_wp)),]"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#projecting-the-crs",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#projecting-the-crs",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Projecting the CRS",
    "text": "Projecting the CRS\nSince the source of our boundary file was an international source, the CRS in use is geographic. What this means is the points are plotted on the earth‚Äôs surface, which is ellipsoid. We need transform the data to the appropriate projected CRS, which will be plotted on a flat surface. Different countries also use different projected CRSs.\n\n\nPress to toggle code\nst_crs(nga_wp_final)\n\n\n\n\n\n\n\nThe code chunk below uses st_transform to transform 'nga_wp_final' to EPSG Code 26392, which is one of the projected coordinate reference systems used for Nigeria.\n\n\nPress to toggle code\nnga_wp_final <- st_transform(nga_wp_final, crs = 26392)\n\n\nChecking if the CRS changed, we have the results below.\n\n\nPress to toggle code\nst_crs(nga_wp_final)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#saving-the-analytical-data-table",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#saving-the-analytical-data-table",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Saving the Analytical Data Table",
    "text": "Saving the Analytical Data Table\nNow that we‚Äôve completed adjusting our data, we can save the new dataset as an RDS file. RDS files are data files native to R. The code chunk below saves our spatial dataframe ‚Äònga_wp_final‚Äô into an RDS file called ‚Äúnga_wp_final.rds‚Äù.\n\n\nPress to toggle code\nwrite_rds(nga_wp_final, \"data/nga_wp_final.rds\")\n\n\nWe can now reload the dataset back to R using read_rds as shown in the code chunk below. We also use the select() function to extract the name of the LGA and relevant derived variables.\n\n\nPress to toggle code\nnga_wp_final <- read_rds(\"data/nga_wp_final.rds\") %>%\n  \n  select(ADM2_EN, \n         total_wpt,\n         wpt_functional,\n         wpt_nonfunctional,\n         pct_functional, \n         pct_nonfunctional, \n         pct_handpump, \n         pct_usagecap1000, \n         pct_usagecaplt1000,\n         pct_rural,\n         pct_pressured)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#using-histograms",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#using-histograms",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Using Histograms",
    "text": "Using Histograms\n\n\nPress to toggle code\nwpt_functional.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `wpt_functional`)) +\n                      geom_histogram(bins=20, \n                                     color=\"black\", \n                                     fill=\"#e3879e\")\n\nwpt_nonfunctional.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `wpt_nonfunctional`)) +\n                        geom_histogram(bins=20, \n                                      color=\"black\", \n                                      fill=\"#e3879e\")\n\npct_functional.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `pct_functional`)) +\n                      geom_histogram(bins=20, \n                                     color=\"black\", \n                                     fill=\"#e3879e\")\n\npct_nonfunctional.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `pct_nonfunctional`)) +\n                        geom_histogram(bins=20, \n                                      color=\"black\", \n                                      fill=\"#e3879e\")\n\npct_handpump.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `pct_handpump`)) +\n                        geom_histogram(bins=20, \n                                      color=\"black\", \n                                      fill=\"#e3879e\")\n\npct_usagecap1000.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `pct_usagecap1000`)) +\n                        geom_histogram(bins=20, \n                                      color=\"black\", \n                                      fill=\"#e3879e\")\n\npct_usagecaplt1000.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `pct_usagecaplt1000`)) +\n                        geom_histogram(bins=20, \n                                      color=\"black\", \n                                      fill=\"#e3879e\")\n\npct_rural.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `pct_rural`)) +\n                 geom_histogram(bins=20, \n                                      color=\"black\", \n                                      fill=\"#e3879e\")\n\npct_pressured.hist <- ggplot(data=nga_wp_final, \n                        aes(x = `pct_pressured`)) +\n                        geom_histogram(bins=20, \n                                      color=\"black\", \n                                      fill=\"#e3879e\")\n\n\nggarrange(wpt_functional.hist, \n          wpt_nonfunctional.hist,\n          pct_functional.hist,\n          pct_nonfunctional.hist,\n          pct_handpump.hist,\n          pct_usagecap1000.hist,\n          pct_usagecaplt1000.hist,\n          pct_rural.hist,\n          pct_pressured.hist,\n          ncol = 3, \n          nrow = 3)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#using-chloropeth-mapping",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#using-chloropeth-mapping",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Using Chloropeth Mapping",
    "text": "Using Chloropeth Mapping\n\n\nPress to toggle code\nwpt_functional.map <- qtm(nga_wp_final, \n                          \"wpt_functional\",\n                          fill.palette = \"RdPu\") + \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\nwpt_nonfunctional.map <- qtm(nga_wp_final, \n                          \"wpt_nonfunctional\",\n                          fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\npct_functional.map <- qtm(nga_wp_final, \n                          \"pct_functional\",\n                          fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\npct_nonfunctional.map <- qtm(nga_wp_final, \n                          \"pct_nonfunctional\",\n                          fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\npct_handpump.map <- qtm(nga_wp_final, \n                        \"pct_handpump\",\n                        fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\npct_usagecap1000.map <- qtm(nga_wp_final, \n                        \"pct_usagecap1000\",\n                        fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\npct_usagecaplt1000.map <- qtm(nga_wp_final, \n                        \"pct_usagecaplt1000\",\n                        fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\npct_rural.map <- qtm(nga_wp_final, \n                      \"pct_rural\",\n                      fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\npct_pressured.map <- qtm(nga_wp_final, \n                      \"pct_pressured\",\n                      fill.palette = \"RdPu\")+ \n                      tm_layout(legend.title.size = 0.5,\n                      legend.text.size = 0.4)\n\n\ntmap_arrange(wpt_functional.map, \n          wpt_nonfunctional.map,\n          pct_functional.map,\n          pct_nonfunctional.map,\n          pct_handpump.map,\n          pct_usagecap1000.map,\n          pct_usagecaplt1000.map,\n          pct_rural.map,\n          pct_pressured.map,\n          ncol = 3, \n          nrow = 3)\n\n\n\n\n\n\n\n\n\n\n\nüå∏ FIRST IMPRESSIONS!\n\n\n\n\nThe ‚Äòpct_functional‚Äô and ‚Äòpct_nonfunctional‚Äô graphs suggest similar findings to the paper discussed in the overview, wherein the northern parts have more functional water points than the south, in terms of percentage.\nIn addition to the previous bullet, the percentage of handpumps (according to the ‚Äòpct_handpump‚Äô map) is much higher in the northern area, which supports the idea that that water technology stays functional for longer.\nBased on the ‚Äòpct_usage1000‚Äô and ‚Äòpct_usagelt1000‚Äô map, it seems that the water points in the northern areas have more capacity for more users, which may also be the reason why these water points stay functional for longer.\nIt seems that based on the ‚Äòpct_rural‚Äô map, there is a high percentage of rural areas all over.\nWhile the ‚Äòpct_pressured‚Äô map is pretty mixed, it does have many polygons on the darker shade suggesting that overall, Nigeria‚Äôs water points are overused and experiencing immense pressure from having to serve too much of one population than it is capable of."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#extracting-clustering-variables",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#extracting-clustering-variables",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Extracting Clustering Variables",
    "text": "Extracting Clustering Variables\nThe code chunk below extracts the clustering variables from the ‚Äònga_wp_final‚Äô simple feature data frame object into just a data frame. The function st_set_geometry(NULL) drops the hidden geometry column of the simple feature data frame object.\n\n\nPress to toggle code\ncluster_vars <- nga_wp_final %>%\n                st_set_geometry(NULL) %>%\n                select(ADM2_EN,\n                wpt_functional,\n                wpt_nonfunctional,\n                pct_functional, \n                pct_nonfunctional, \n                pct_handpump, \n                pct_usagecap1000, \n                pct_usagecaplt1000,\n                pct_rural,\n                pct_pressured)\n\nhead(cluster_vars,10)\n\n\n          ADM2_EN wpt_functional wpt_nonfunctional pct_functional\n1       Aba North              7                 9      0.4117647\n2       Aba South             29                35      0.4084507\n4           Abaji             23                34      0.4035088\n5            Abak             23                25      0.4791667\n6       Abakaliki             82                42      0.3519313\n7  Abeokuta North             16                15      0.4705882\n8  Abeokuta South             72                33      0.6050420\n9             Abi             79                62      0.5197368\n10    Aboh-Mbaise             18                26      0.2727273\n11     Abua/Odual             25                13      0.6410256\n   pct_nonfunctional pct_handpump pct_usagecap1000 pct_usagecaplt1000\n1          0.5294118   0.11764706        0.8235294         0.17647059\n2          0.4929577   0.09859155        0.8732394         0.12676056\n4          0.5964912   0.40350877        0.5964912         0.40350877\n5          0.5208333   0.08333333        0.9166667         0.08333333\n6          0.1802575   0.43776824        0.0944206         0.90557940\n7          0.4411765   0.14705882        0.7647059         0.23529412\n8          0.2773109   0.16806723        0.7058824         0.29411765\n9          0.4078947   0.59868421        0.3289474         0.67105263\n10         0.3939394   0.01515152        0.6515152         0.34848485\n11         0.3333333   0.30769231        0.6666667         0.33333333\n    pct_rural pct_pressured\n1  0.00000000     0.8235294\n2  0.05633803     0.6197183\n4  0.84210526     0.8070175\n5  0.83333333     0.7708333\n6  0.87553648     0.2660944\n7  0.20588235     0.5294118\n8  0.00000000     0.2016807\n9  0.95394737     0.2828947\n10 0.72727273     0.5909091\n11 0.53846154     0.9230769\n\n\nThe code chunk below changes the row ID or row name to LGA names.\n\n\nPress to toggle code\nrow.names(cluster_vars) <- cluster_vars$ADM2_EN\n\ncluster_vars <- select(cluster_vars, c(2:10))\n\nhead(cluster_vars)\n\n\n               wpt_functional wpt_nonfunctional pct_functional\nAba North                   7                 9      0.4117647\nAba South                  29                35      0.4084507\nAbaji                      23                34      0.4035088\nAbak                       23                25      0.4791667\nAbakaliki                  82                42      0.3519313\nAbeokuta North             16                15      0.4705882\n               pct_nonfunctional pct_handpump pct_usagecap1000\nAba North              0.5294118   0.11764706        0.8235294\nAba South              0.4929577   0.09859155        0.8732394\nAbaji                  0.5964912   0.40350877        0.5964912\nAbak                   0.5208333   0.08333333        0.9166667\nAbakaliki              0.1802575   0.43776824        0.0944206\nAbeokuta North         0.4411765   0.14705882        0.7647059\n               pct_usagecaplt1000  pct_rural pct_pressured\nAba North              0.17647059 0.00000000     0.8235294\nAba South              0.12676056 0.05633803     0.6197183\nAbaji                  0.40350877 0.84210526     0.8070175\nAbak                   0.08333333 0.83333333     0.7708333\nAbakaliki              0.90557940 0.87553648     0.2660944\nAbeokuta North         0.23529412 0.20588235     0.5294118"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#performing-correlation-analysis",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#performing-correlation-analysis",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Performing Correlation Analysis",
    "text": "Performing Correlation Analysis\nNow that we have our tentative clustering variables, we can perform the correlation analysis.\nThe cor() function is used to measure the correlation coefficient between all our variables from ‚Äònga_wp_final‚Äô.\n\n\nPress to toggle code\ncluster_vars.cor = cor(cluster_vars)\n\n\nThe code chunk below uses the corrplot.mixed() to visualize and analyse the correlation of the input variables. It‚Äôs a special function used for mixed visualization style, where we can set the visual methods for the lower and upper triangle separately.\n\n\nPress to toggle code\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\n\n\n\nThe plot above shows that 'pct_handpump' and 'pct_usagecap1000' and 'pct_usagecaplt1000' are highly correlated. This makes sense because in terms of usage capacity values, the two columns are opposite values. It also makes sense that 'pct_handpump' is related to the two since the type of water technology used dictates usage capacity."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#dropping-highly-correlated-variables",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#dropping-highly-correlated-variables",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Dropping Highly Correlated Variables",
    "text": "Dropping Highly Correlated Variables\nBecause of the result above, we will keep 'usage_cap1000' and drop the other two variables. This decision was made based on 'usage_cap1000' being less correlated to the remaining variables compared to 'pct_handpump' and because in the context of the problem, if a water point has relatively high usage capacity, it could describe a better water technology that serves more of the population and shows progress.\nThe code block is used to remove the columns 'pct_handpump' and 'pct_usagecaplt1000' using the code snippet -c(5,7) which refers to the column numbers. Setting drop = FALSE retains the data frame.\n\n\nPress to toggle code\ncluster_vars <- cluster_vars[,-c(5,7),drop=FALSE]"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#data-standardization",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#data-standardization",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Data Standardization",
    "text": "Data Standardization\nOur clustering variables aren‚Äôt all in the same scale since some are measured in count and other are measured in percentage. To deal with this, we standardize our variables using the normalize() function which uses Min-Max Standardization by default.\n\n\n\n\n\n\nüìñ LECTURE REVIEW!\n\n\n\nThis is a common standardization technique where the maximum value gets transformed into a 1 and the minimum value gets transformed to 0. All variable will then be scaled to to values that are decimal values between 0 and 1. The formula is as follows:\n\\[\nMM(x_{ij}) = \\dfrac{x_{ij}-x_{min}}{x_{max}-x_{min}}\n\\]\n\n\nThe code chunk below shows us the ranges of our clustering variables. The following code chunk performs the data standardization.\n\n\nPress to toggle code\nsummary(cluster_vars)\n\n\n\n\n\n\n\n\n\nPress to toggle code\ncluster_vars.std <- normalize(cluster_vars)\n\n\n\n\n\n\n\nAs shown above, we now have standardized values ranging from 0 to 1 for all clustering variables."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#proximity-matrix",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#proximity-matrix",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Proximity Matrix",
    "text": "Proximity Matrix\nA proximity matrix is used to measure similarity or dissimilarity. The code chunk below uses dist() to create a proximity matrix using the ‚Äôeuclidean‚Äô method. The function dist() also supports maximum, manhattan, canberra, binary and minkowski methods.\n\n\nPress to toggle code\nproxmat <- dist(cluster_vars.std, method = 'euclidean')"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#optimal-clustering-method",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#optimal-clustering-method",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Optimal Clustering Method",
    "text": "Optimal Clustering Method\nOne of the challenge in performing hierarchical clustering is to identify stronger clustering structures. The issue can be solved by using the agnes() function. It functions like hclust(), however, with agnes() you can also get the agglomerative coefficient, which measures the amount of clustering structure found and values closer to 1 suggest strong clustering structure.\nBefore we proceed to compute for the hierarchical clusters, let‚Äôs take a look at which method is best to use. The code chunk below will be used to compute the agglomerative coefficients of hierarchical clustering algorithms, namely ‚Äòaverage‚Äô, ‚Äòsingle‚Äô, ‚Äòcomplete‚Äô and ‚Äòward‚Äô.\n\n\nPress to toggle code\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(cluster_vars.std, method = x)$ac\n}\n\nmap_dbl(m, ac)\n\n\n  average    single  complete      ward \n0.8816959 0.7842007 0.9235207 0.9837225 \n\n\nBased on the results above, Ward‚Äôs method has the strongest agglomerative coefficient."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#optimal-number-of-clusters",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#optimal-number-of-clusters",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Optimal Number of Clusters",
    "text": "Optimal Number of Clusters\nAnother technical challenge faced by data analysts in performing clustering analysis is to determine the optimal clusters to retain. For our case, we will use the Gap Statistic method.\nThe gap statistic compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The estimate of the optimal clusters will be value that maximize the gap statistic (i.e., that yields the largest gap statistic). This means that the clustering structure is far away from the random uniform distribution of points.\nTo compute the gap statistic, the function clusGap() is used as shown below.\n\n\nPress to toggle code\nset.seed(12345)\ngap_stat <- clusGap(cluster_vars.std, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n\nprint(gap_stat, method = \"firstmax\")\n\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = cluster_vars.std, FUNcluster = hcut, K.max = 10, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 10\n          logW   E.logW       gap      SE.sim\n [1,] 5.040786 5.664420 0.6236343 0.008228577\n [2,] 4.920277 5.564951 0.6446742 0.011570199\n [3,] 4.825701 5.511000 0.6852986 0.009420611\n [4,] 4.746339 5.463967 0.7176283 0.009748559\n [5,] 4.704941 5.428949 0.7240078 0.008853350\n [6,] 4.666954 5.398706 0.7317517 0.007328457\n [7,] 4.630720 5.371332 0.7406119 0.006129368\n [8,] 4.591102 5.347039 0.7559367 0.006183039\n [9,] 4.561602 5.325420 0.7638186 0.006440480\n[10,] 4.536875 5.305569 0.7686938 0.007188619\n\n\nThe function fviz_gap_stat() is used to visualized the gap statistics results. As shown, the suggest number of clusters is 9.\n\n\nPress to toggle code\nfviz_gap_stat(gap_stat, linecolor = \"#cb6a82\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#computing-hierarchical-clusters",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#computing-hierarchical-clusters",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Computing Hierarchical Clusters",
    "text": "Computing Hierarchical Clusters\nThe code chunk below uses the function hclust() to create clusters using the agglomeration method. The 'method' was set to ‚Äòward.D‚Äô since as established two subsections ago, Ward‚Äôs method has the strongest clustering structure.\n\n\nPress to toggle code\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n\n\nWe can then plot the tree using plot() as shown in the code chunk below. We also can use rect.hclust() to draw borders around the selected clusters. Since we established that the suggested cluster count is 9, we will group 9 different clusters.\n\n\nPress to toggle code\nplot(hclust_ward, cex = 0.25, col = \"#cb6a82\")\n\nrect.hclust(hclust_ward, \n            k = 9, \n            border = 2:5)\n\n\n\n\n\nBecause of the vast amount of records (761!) it would be difficult to see each individual cluster and the early hierarchical stage, however the basic idea of the larger scale clusters is visible. The height of the fusion, provided on the vertical axis, indicates the (dis)similarity between two observations. The higher the height of the fusion, the less similar the observations are."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#visualizing-the-clusters",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#visualizing-the-clusters",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Visualizing the Clusters",
    "text": "Visualizing the Clusters\n\nCreating a cluster variables heatmap\n\n\nPress to toggle code\ncluster_vars_mat <- data.matrix(cluster_vars.std)\n\nheatmaply(normalize(cluster_vars_mat),\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = RdPu,\n          k_row = 9,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Segmentation of Nigerian LGAs by Water Point Stats\",\n          xlab = \"Water Point Stats\",\n          ylab = \"LGAs of Nigeria\")\n\n\n\n\n\n\nGiven the heatmap above, a table describing the patterns of the variable values under each cluster is made below. The following estimations are used as descriptors: High (0.75-1), Above Average (~0.5-0.75), Average ( ~0.5), Below Average ( ~0.25-0.5), Low (0-0.25).\n\n\n\n\n\n\n\n\n\n\n\n\n\nCluster\nFunctional Water Points\nNon-Functional Water Points\nFunctional (%)\nNon-Functional (%)\nUsage Capacity > 1000 (%)\nRural (%)\nPressure Score > 1 (%)\n\n\n\n\n1\n(Pink)\nAbove Average\nBelow Average\nHigh\nLow\nLow\nHigh\nBelow Average\n\n\n2\n(Purple)\nBelow Average\nAverage\nAverage\nAverage\nBelow Average\nHigh\nAverage\n\n\n3\n(Blue)\nBelow\nBelow Average\nAbove Average\nBelow Average\nAverage\nHigh\nAbove Average\n\n\n4\n(Blue Green)\nLow\nLow\nHigh\nLow\nHigh\nHigh\nAbove Average\n\n\n5\n(Green)\nLow\nBelow Average\nAbove Average\nBelow Average\nHigh\nLow\nBelow Average\n\n\n6\n(Dark Green)\nBelow Average\nBelow Average\nAbove Average\nAverage\nAverage\nBelow Average\nAverage\n\n\n7\n(Gold)\nAverage\nAverage\nAverage\nAverage\nAverage\nAbove Average\nAbove Average\n\n\n8\n(Orange)\nBelow Average\nBelow Average\nAverage\nAbove Average\nHigh\nLow\nHigh\n\n\n9\n(Red)\nLow\nBelow Average\nAverage\nAbove Average\nHigh\nHigh\nAbove Average\n\n\n\n\n\nMapping the clusters\nThe function cutree() will be used in the code chunk below to derive a 9-cluster model. It takes the resulting tree from hclust() and splits it to several groups by specifying the desired number of groups ('k' argument) or the cut heights. In order to visualize the clusters, the ‚Äôgroups‚Äô object needs to be appended onto the ‚Äônga_wp_final‚Äô simple feature object.\n\n\nPress to toggle code\ngroups <- as.factor(cutree(hclust_ward, k=9))\n\nnga_wp_cluster <- cbind(nga_wp_final, as.matrix(groups)) %>%\n                  rename(`CLUSTER`=`as.matrix.groups.`)\n\n\nThe code chunk below uses qtm() to plot the chloropleth map colored based on cluster groupings.\n\n\nPress to toggle code\nqtm(nga_wp_cluster, \"CLUSTER\", fill.palette = \"Set3\")\n\n\n\n\n\nThe choropleth map above reveals from the mixed up colors that the clusters are very fragmented. The is one of the major limitation when non-spatial clustering algorithm such as hierarchical cluster analysis method is used.\n\nUsing parallel coordinate plots\nTo support the heatmap and chloropleth map above, we can create parallel coordinate plots that help visualize the patterns in clustering variable values. The function ggparcoord() is used below to create multiple coordinate plots and group by cluster. The argument ‚Äòscale‚Äô is set to ‚Äúuniminmax‚Äù to scale the values between 0 and 1, just like the standardization done earlier.\n\n\nPress to toggle code\nggparcoord(data = nga_wp_cluster, \n           columns = c(3,4,5,6,8,10,11), \n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           groupColumn = \"CLUSTER\",\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of Water Point Stats in Nigerian LGAs by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 90, \n                                   size = 8,\n                                   vjust = 0.2), \n        title = element_text(size = 13)) +\n  scale_color_brewer(palette = \"Set3\")\n\n\n\n\n\n\n\n\n\nüîé FIRST OBSERVATIONS!\n\n\n\n\nDespite this clustering not having spatial constraints, from the chloropleth map you can still observe that some of the northern LGAs are clustered together in Cluster 9. According to the coordinates plot, these LGAs in this cluster have a high percentage of functional water points and have mostly rural areas.\nCluster 3 seems to have the highest average percentage of non-functional water points. While geographic constraints have not been applied, it seems like most of the Cluster 3 LGAs are towards the south. It also seems that most water points have a usage capacity of 1000. If the water technology is associated with the usage capacity, it is possible that while the water point has a high number of max users, it is not sustainable and starts to fail.\nComparing Cluster 3 and Cluster 9 there is a clear difference in percentage of functional water points and percentage of water points with a usage capacity of 1000. While both have a high average of rural areas, it seems that both clusters are using different water technologies. Cluster 9 has lesser water capacity, but probably uses water technology that lasts and is viable in a rural area. Cluster 3 might be using a water technology not practical in a rural area.\nCluster 1 seems to comprise of little urbanized LGAs. They also have many pressured water points, suggesting that these urban areas have a high population using a single water point."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#skater-approach",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#skater-approach",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "SKATER Approach",
    "text": "SKATER Approach\nSKATER stands for ‚ÄúSpatial Kluster Analysis by Tree Edge Removal‚Äù and it is a regionalization method for clustering based on the location by spatial autocorrelation and spatial patterns. It constructs the minimum spanning tree from the adjacency matrix and cuts the tree to achieve maximum internal homogeneity.\n\nConverting to SpatialPolygonDataFrame object\nThe skater() function only supports sp objects like SpatialPolygonDataFrame. This is because the sf package was created later than the when the skater() function was made, so there is no support yet for simple features objects.\nThe code chunk uses as_Spatial() function converts ‚Äònga_wp_final‚Äô to a SpatialPolygonDataFrame called ‚Äônga_wp_sp‚Äô.\n\n\nPress to toggle code\nnga_wp_sp <- as_Spatial(nga_wp_final)\n\n\n\n\nComputing for the list of neighbors\nSince we‚Äôve established that the SKATER method takes into account spatial patterns, we need to figure out the different neighbors of each feature using poly2nb() , which if we recall, creates a list of neighbors based on the queen‚Äôs method by default.\n\n\nPress to toggle code\nnga_wp_nb <- poly2nb(nga_wp_sp)\n\nsummary(nga_wp_nb)\n\n\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n138 509 525 560 with 1 link\n1 most connected region:\n508 with 14 links\n\n\nThe summary tells us that there 4348 link in total. Four LGAs have only 1 neighbor, while one LGA has 14 neighbors. Fortunately, no LGA has 0 neighbors.\nThe code chunk below produces a plot that shows the links made between the neighboring LGAs.\n\n\nPress to toggle code\nplot(nga_wp_sp, \n     border = grey(.5))\n\nplot(nga_wp_nb, \n     coordinates(nga_wp_sp), \n     col = \"#cb6a82\", \n     pch = 1,\n     add = TRUE)\npoints(coordinates(nga_wp_sp), col = \"#704276\", pch = 20)\n\n\n\n\n\n\n\n\n\nComputing the minimum spanning tree (MST)\nBy getting the MST, we can minimize the sum of dissimilarities over all the nodes.\n\nCalculating edge costs\nThe code chunk below uses nbcosts() to compute the cost of each edge given the neighbors list and clustering variables.\n\n\nPress to toggle code\nlcosts <- nbcosts(nga_wp_nb, cluster_vars.std)\n\n\nFor each observation, this gives the pairwise dissimilarity between its values on the seven variables and the values for the neighboring observation (from the neighbor list).\nNext, We will incorporate these costs into a weights object. In other words, we will convert the neighbor list to a list weights object using ng2listw() and we specified ‚Äòlcosts‚Äô as the weights.\n\n\nPress to toggle code\nnga_wp_weights <- nb2listw(nga_wp_nb, \n                   lcosts, \n                   style=\"B\")\nsummary(nga_wp_weights)\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n138 509 525 560 with 1 link\n1 most connected region:\n508 with 14 links\n\nWeights style: B \nWeights constants summary:\n    n     nn       S0       S1       S2\nB 761 579121 2370.842 3195.682 35274.96\n\n\n\n\nComputing for the MST\nThe code chunk below uses the function mstree() to compute for the minimum spanning tree.\n\n\nPress to toggle code\nnga_wp_mst <- mstree(nga_wp_weights)\n\nhead(nga_wp_mst)\n\n\n     [,1] [,2]      [,3]\n[1,]  733  724 0.4204403\n[2,]  733  575 0.4825116\n[3,]  575  706 0.3906946\n[4,]  706  707 0.3092344\n[5,]  707  132 0.3740311\n[6,]  132  119 0.4087773\n\n\nThe results tells us that a row is an edge and the first two columns are the linked LGAs. The last column is the minimized cost. Plotting it using the code chunk below, we can visualize the MST.\n\n\nPress to toggle code\nplot(nga_wp_sp, border=gray(.5))\nplot.mst(nga_wp_mst, \n         coordinates(nga_wp_sp), \n         col=\"#cb6a82\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n\n\n\n\n\n\n\n\n\n\nComputing spatially constrained clusters using SKATER method\nThe code chunk below computes spatially constrained clusters using skater() function. It takes three mandatory arguments: - the first two columns of the MST matrix (i.e.¬†not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts (which is one less than the number of clusters).\n\n\nPress to toggle code\nclust9 <- skater(edges = nga_wp_mst[,1:2], \n                 data = cluster_vars.std, \n                 method = \"euclidean\", \n                 ncuts = 8)\n\nstr(clust9)\n\n\nList of 8\n $ groups      : num [1:761] 5 5 3 5 9 4 4 9 2 1 ...\n $ edges.groups:List of 9\n  ..$ :List of 3\n  .. ..$ node: num [1:80] 742 498 36 387 314 209 208 197 595 511 ...\n  .. ..$ edge: num [1:79, 1:3] 749 650 42 624 536 155 188 365 25 365 ...\n  .. ..$ ssw : num 40.6\n  ..$ :List of 3\n  .. ..$ node: num [1:78] 9 539 214 717 332 101 370 715 606 22 ...\n  .. ..$ edge: num [1:77, 1:3] 22 524 606 715 187 286 285 101 370 566 ...\n  .. ..$ ssw : num 35.6\n  ..$ :List of 3\n  .. ..$ node: num [1:264] 235 460 159 93 439 643 718 90 154 690 ...\n  .. ..$ edge: num [1:263, 1:3] 439 218 718 690 154 84 420 73 64 489 ...\n  .. ..$ ssw : num 122\n  ..$ :List of 3\n  .. ..$ node: num [1:145] 14 81 346 174 212 531 542 276 355 16 ...\n  .. ..$ edge: num [1:144, 1:3] 310 311 545 542 194 276 355 585 559 531 ...\n  .. ..$ ssw : num 70.3\n  ..$ :List of 3\n  .. ..$ node: num [1:49] 359 538 201 325 282 725 280 527 574 526 ...\n  .. ..$ edge: num [1:48, 1:3] 611 574 600 713 135 2 327 359 359 535 ...\n  .. ..$ ssw : num 18.9\n  ..$ :List of 3\n  .. ..$ node: num [1:17] 48 50 610 503 31 669 320 61 205 21 ...\n  .. ..$ edge: num [1:16, 1:3] 50 31 50 48 48 320 50 50 50 610 ...\n  .. ..$ ssw : num 7.73\n  ..$ :List of 3\n  .. ..$ node: num [1:50] 406 82 253 755 392 376 164 231 492 693 ...\n  .. ..$ edge: num [1:49, 1:3] 231 492 693 225 32 475 32 414 227 730 ...\n  .. ..$ ssw : num 20.2\n  ..$ :List of 3\n  .. ..$ node: num [1:24] 754 130 467 692 432 265 89 223 382 158 ...\n  .. ..$ edge: num [1:23, 1:3] 432 467 692 265 692 89 265 223 465 158 ...\n  .. ..$ ssw : num 16.6\n  ..$ :List of 3\n  .. ..$ node: num [1:54] 161 13 576 168 613 413 131 249 262 722 ...\n  .. ..$ edge: num [1:53, 1:3] 576 13 168 613 5 613 533 727 262 262 ...\n  .. ..$ ssw : num 17.6\n $ not.prune   : NULL\n $ candidates  : int [1:9] 1 2 3 4 5 6 7 8 9\n $ ssto        : num 440\n $ ssw         : num [1:9] 440 424 400 387 376 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:761] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n\n\nUsing the following code chunk, we can see the number of LGAs in each cluster.\n\n\nPress to toggle code\nccs9 <- clust9$groups\n\ntable(ccs9)\n\n\nccs9\n  1   2   3   4   5   6   7   8   9 \n 80  78 264 145  49  17  50  24  54 \n\n\nCluster 7 has the most members, with 264, while Cluster 6 has the least with only 17 members.\n\n\nVisualizing the spatial clusters on a chloropleth map\nThe code chunk below adds the SKATER cluster groupings to the ‚Äònga_wp_cluster‚Äô object. Using qtm() we can visualize the cluster groupings on a chloropleth map.\n\n\nPress to toggle code\ngroups_mat <- as.matrix(clust9$groups)\n\nnga_wp_cluster <- cbind(nga_wp_cluster, \n                        as.factor(groups_mat)) %>%\n                  rename(`SKATER_CLUSTER`=`as.factor.groups_mat.`)\n\nqtm(nga_wp_cluster, \n    \"SKATER_CLUSTER\", \n    fill_palette  = (\"Set3\")) +\ntm_layout(legend.width = 0.3,\n          legend.height = 0.3)\n\n\n\n\n\n\n\nUsing parallel coordinate plots\nTo see the patterns in clustering variables for each cluster we have ggparcoord() as shown in the code chunk below.\n\n\nPress to toggle code\nggparcoord(data = nga_wp_cluster, \n           columns = c(3,4,5,6,8,10,11), \n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           groupColumn = \"SKATER_CLUSTER\",\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of Water Point Stats in Nigerian LGAs by SKATER Cluster\") +\n  facet_grid(~ SKATER_CLUSTER) + \n  theme(axis.text.x = element_text(angle = 90, \n                                   size = 8,\n                                   vjust = 0.2), \n        title = element_text(size = 13)) +\n  scale_color_brewer(palette = \"Set3\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nüîé NEXT OBSERVATIONS!\n\n\n\nFor the following observations, this map will be used as reference when referring to regions:\n\n\n\n\n\n\nFrom the chloropleth map, it seems that a huge chunk of Nigeria is considered part of Cluster 7 and it is comprised of Northern LGAs from the North West, North Central and (some from the) North East regions. LGAs from this cluster have mostly rural areas and a good percentage of functional water points. Notably, most water points have a usage capacity of 1000. In contrast, Cluster 1 is also located in the North, particularly North East region, and it also has a good percentage of functional water points. However, it mostly has water points with a usage capacity less than 1000. This region is mostly known for producing crops.\nCluster 6 comprises of a few small LGAs in the South West region. What‚Äôs notable about this cluster is that most water points have pressured water points (meaning, one water point caters to more population than its usage capacity). This could be a product of the LGAs in this cluster being urban, therefore more populated. It‚Äôs also possible that Cluster 3 which has more non-functional water points (in count and percentage) may be relying on the functional water points in Cluster 6, which adds on to the population using making use of it.\nCluster 4 and 5 are located in the South-South region of Nigeria and have the highest average percentage of non-functional water points. They have a relatively high number of rural areas, water points with usage capacity at 1000 and over-utilized water points. This goes back to maybe the water technology not being suitable for the rural environment and maintenance not being able to reach them. The over-utilization may have also affected the non-functionality but can also be a product of only having a few functional water points that the population can use.\nFUN OBSERVATION: Cluster 2 almost follows the shape of the South East region."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-hierarchical-clustering",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-hierarchical-clustering",
    "title": "Take-home Exercise 2: Regionalization of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Spatially Constrained Hierarchical Clustering",
    "text": "Spatially Constrained Hierarchical Clustering\nNext, we will be using hclustgeo() function from the ClustGeo package which implements a Ward-like hierarchical clustering algorithm while taking into account spatial autocorrelation. The use of choicealpha() allows us to balance the contiguous influence and clustering variables.\n\nGetting the distance matrix\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix is derived by using st_distance(). The function as.dist() is used to create a matrix from the data frame.\n\n\nPress to toggle code\ndist <- st_distance(nga_wp_final, nga_wp_final)\n\ndistmat <- as.dist(dist)\n\n\n\n\nLooking for alpha\nNext, choicealpha() will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\n\nPress to toggle code\ncr <- choicealpha(proxmat, \n                  distmat, \n                  range.alpha = seq(0, 1, 0.1), \n                  K = 9, \n                  graph = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nThe graph above suggests that having an approximate alpha value of 0.4 is the most optimal.\n\n\nComputing for the spatially constrained hierarchical clusters\nThe code chunk below uses hclustgeo() to produce the cluster tree. We set alpha to 0.4 because of the results from the previous subsection.\n\n\nPress to toggle code\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.4)\n\ngroups <- as.factor(cutree(clustG, k = 9))\n\nnga_wp_cluster <- cbind(nga_wp_cluster, as.matrix(groups)) %>%\n  rename(`HCLUSTGEO_CLUSTER` = `as.matrix.groups.`)\n\nqtm(nga_wp_cluster, \n    \"HCLUSTGEO_CLUSTER\", \n    fill.palette = \"Set3\")+\ntm_layout(legend.width = 0.3,\n          legend.height = 0.3)\n\n\n\n\n\n\n\n\n\n\n\nüå∏ FIRST IMPRESSION!\n\n\n\nVisually, the clusters may seem a bit fragmented - especially for the south to southwest side. However, the cluster coloring is still within a certain degree of neighbor. There are no obvious cluster groupings that have members settling on the opposite side of the map. Given that we measured in distance, it‚Äôs not surprising the neighbors aren‚Äôt only those contiguous. There is a clear attempt to balance the spatial factor and the strength of the clustering variables.\n\n\n\n\nUsing parallel coordinate plots\nAnd finally once again, to see the plotting of clustering variables for each cluster we have ggparcoord() as shown in the code chunk below.\n\n\nPress to toggle code\nggparcoord(data = nga_wp_cluster, \n           columns = c(3,4,5,6,8,10,11), \n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           groupColumn = \"HCLUSTGEO_CLUSTER\",\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of Water Point Stats in Nigerian LGAs by HClustGeo Cluster\") +\n  facet_grid(~ HCLUSTGEO_CLUSTER) + \n  theme(axis.text.x = element_text(angle = 90, \n                                   size = 8,\n                                   vjust = 0.2), \n        title = element_text(size = 13))+\n  scale_color_brewer(palette = \"Set3\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nüîé FINAL OBSERVATION!\n\n\n\n\n\n\n\n\n\nClusters 7 and 8 seem to have the highest average percentage of functional water points. They are both located towards the North West and North East regions of Nigeria. Both are comprised of rural areas but Cluster 7 has a more defined percentage range of water points with a usage capacity less than 1000.\nCluster 3 is located around the South South to South East regions of Nigeria and it has the highest average percentage of non-functional water points. It seems that most of the water points have high usage capacity, but are still pressured or are at over capacity. This may be due to water technology not being appropriate for the rural setting, or the very number of water points is lacking so much that it needs to cater to many people.\nCluster 1 is also located around the South regions, but it still has a relatively lower range of non-functional water point percentages in comparison to Cluster 3. It is however, mostly urbanized areas and has a very high average of over-utilized water points, given being a heavily populated area and having water points with mostly less than 1000 usage capacity.\nClusters 4 and 5 are located towards the South West to North Central areas of Nigeria. They have very similar statistics with the only difference being that Cluster 4 comprises of urban areas and Cluster 5 comprises of rural areas."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#convert-sf-to-sp-1",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#convert-sf-to-sp-1",
    "title": "In-class Exercise 5",
    "section": "Convert sf to sp",
    "text": "Convert sf to sp\nBecause gwmodel can only perform functions on sp objects, we need to convert our sf object using as_Spatial() but without the two not statistically significant variables.\n\n\nPress to toggle code\nosun_wp_sp2 <- osun_wp_sf_clean %>% \n  select(c(status,\n           distance_to_tertiary_road,\n           distance_to_city,\n           distance_to_town,\n           water_point_population,\n           local_population_1km,\n           is_urban,\n           usage_capacity,\n           water_source_clean)) %>% \n  as_Spatial()\n\nosun_wp_sp2\n\n\nclass       : SpatialPointsDataFrame \nfeatures    : 4756 \nextent      : 182502.4, 290751, 340054.1, 450905.3  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=4 +lon_0=8.5 +k=0.99975 +x_0=670553.98 +y_0=0 +a=6378249.145 +rf=293.465 +towgs84=-92,-93,122,0,0,0,0 +units=m +no_defs \nvariables   : 9\nnames       : status, distance_to_tertiary_road, distance_to_city, distance_to_town, water_point_population, local_population_1km, is_urban, usage_capacity, water_source_clean \nmin values  :      0,         0.017815121653488, 53.0461399623541, 30.0019777713073,                      0,                    0,        0,           1000,           Borehole \nmax values  :      1,          10966.2705628969,  47934.343603562, 44020.6393368124,                  29697,                36118,        1,            300,   Protected Spring"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#building-fixed-bandwidth-1",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#building-fixed-bandwidth-1",
    "title": "In-class Exercise 5",
    "section": "Building Fixed Bandwidth",
    "text": "Building Fixed Bandwidth\n\n\nPress to toggle code\nbw.fixed2 <- bw.ggwr(status ~ \n                 distance_to_tertiary_road +\n                 distance_to_city +\n                 distance_to_town +\n                 water_point_population +\n                 local_population_1km +\n                 usage_capacity +\n                 is_urban +\n                 water_source_clean,\n                 data = osun_wp_sp2,\n                 family = \"binomial\",\n                 approach = \"AIC\",\n                 kernel = \"gaussian\",\n                 adaptive = FALSE,\n                 longlat = FALSE)\n\n\nTake a cup of tea and have a break, it will take a few minutes.\n          -----A kind suggestion from GWmodel development group\n Iteration    Log-Likelihood:(With bandwidth:  95768.67 )\n=========================\n       0        -2890 \n       1        -2837 \n       2        -2830 \n       3        -2829 \n       4        -2829 \n       5        -2829 \nFixed bandwidth: 95768.67 AICc value: 5681.18 \n Iteration    Log-Likelihood:(With bandwidth:  59200.13 )\n=========================\n       0        -2878 \n       1        -2820 \n       2        -2812 \n       3        -2810 \n       4        -2810 \n       5        -2810 \nFixed bandwidth: 59200.13 AICc value: 5645.901 \n Iteration    Log-Likelihood:(With bandwidth:  36599.53 )\n=========================\n       0        -2854 \n       1        -2790 \n       2        -2777 \n       3        -2774 \n       4        -2774 \n       5        -2774 \n       6        -2774 \nFixed bandwidth: 36599.53 AICc value: 5585.354 \n Iteration    Log-Likelihood:(With bandwidth:  22631.59 )\n=========================\n       0        -2810 \n       1        -2732 \n       2        -2711 \n       3        -2707 \n       4        -2707 \n       5        -2707 \n       6        -2707 \nFixed bandwidth: 22631.59 AICc value: 5481.877 \n Iteration    Log-Likelihood:(With bandwidth:  13998.93 )\n=========================\n       0        -2732 \n       1        -2635 \n       2        -2604 \n       3        -2597 \n       4        -2596 \n       5        -2596 \n       6        -2596 \nFixed bandwidth: 13998.93 AICc value: 5333.718 \n Iteration    Log-Likelihood:(With bandwidth:  8663.649 )\n=========================\n       0        -2624 \n       1        -2502 \n       2        -2459 \n       3        -2447 \n       4        -2446 \n       5        -2446 \n       6        -2446 \n       7        -2446 \nFixed bandwidth: 8663.649 AICc value: 5178.493 \n Iteration    Log-Likelihood:(With bandwidth:  5366.266 )\n=========================\n       0        -2478 \n       1        -2319 \n       2        -2250 \n       3        -2225 \n       4        -2219 \n       5        -2219 \n       6        -2220 \n       7        -2220 \n       8        -2220 \n       9        -2220 \nFixed bandwidth: 5366.266 AICc value: 5022.016 \n Iteration    Log-Likelihood:(With bandwidth:  3328.371 )\n=========================\n       0        -2222 \n       1        -2002 \n       2        -1894 \n       3        -1838 \n       4        -1818 \n       5        -1814 \n       6        -1814 \nFixed bandwidth: 3328.371 AICc value: 4827.587 \n Iteration    Log-Likelihood:(With bandwidth:  2068.882 )\n=========================\n       0        -1837 \n       1        -1528 \n       2        -1357 \n       3        -1261 \n       4        -1222 \n       5        -1222 \nFixed bandwidth: 2068.882 AICc value: 4772.046 \n Iteration    Log-Likelihood:(With bandwidth:  1290.476 )\n=========================\n       0        -1403 \n       1        -1016 \n       2       -807.3 \n       3       -680.2 \n       4       -680.2 \nFixed bandwidth: 1290.476 AICc value: 5809.721 \n Iteration    Log-Likelihood:(With bandwidth:  2549.964 )\n=========================\n       0        -2019 \n       1        -1753 \n       2        -1614 \n       3        -1538 \n       4        -1506 \n       5        -1506 \nFixed bandwidth: 2549.964 AICc value: 4764.056 \n Iteration    Log-Likelihood:(With bandwidth:  2847.289 )\n=========================\n       0        -2108 \n       1        -1862 \n       2        -1736 \n       3        -1670 \n       4        -1644 \n       5        -1644 \nFixed bandwidth: 2847.289 AICc value: 4791.834 \n Iteration    Log-Likelihood:(With bandwidth:  2366.207 )\n=========================\n       0        -1955 \n       1        -1675 \n       2        -1525 \n       3        -1441 \n       4        -1407 \n       5        -1407 \nFixed bandwidth: 2366.207 AICc value: 4755.524 \n Iteration    Log-Likelihood:(With bandwidth:  2252.639 )\n=========================\n       0        -1913 \n       1        -1623 \n       2        -1465 \n       3        -1376 \n       4        -1341 \n       5        -1341 \nFixed bandwidth: 2252.639 AICc value: 4759.188 \n Iteration    Log-Likelihood:(With bandwidth:  2436.396 )\n=========================\n       0        -1980 \n       1        -1706 \n       2        -1560 \n       3        -1479 \n       4        -1446 \n       5        -1446 \nFixed bandwidth: 2436.396 AICc value: 4756.675 \n Iteration    Log-Likelihood:(With bandwidth:  2322.828 )\n=========================\n       0        -1940 \n       1        -1656 \n       2        -1503 \n       3        -1417 \n       4        -1382 \n       5        -1382 \nFixed bandwidth: 2322.828 AICc value: 4756.471 \n Iteration    Log-Likelihood:(With bandwidth:  2393.017 )\n=========================\n       0        -1965 \n       1        -1687 \n       2        -1539 \n       3        -1456 \n       4        -1422 \n       5        -1422 \nFixed bandwidth: 2393.017 AICc value: 4755.57 \n Iteration    Log-Likelihood:(With bandwidth:  2349.638 )\n=========================\n       0        -1949 \n       1        -1668 \n       2        -1517 \n       3        -1432 \n       4        -1398 \n       5        -1398 \nFixed bandwidth: 2349.638 AICc value: 4755.753 \n Iteration    Log-Likelihood:(With bandwidth:  2376.448 )\n=========================\n       0        -1959 \n       1        -1680 \n       2        -1530 \n       3        -1447 \n       4        -1413 \n       5        -1413 \nFixed bandwidth: 2376.448 AICc value: 4755.48 \n Iteration    Log-Likelihood:(With bandwidth:  2382.777 )\n=========================\n       0        -1961 \n       1        -1683 \n       2        -1534 \n       3        -1450 \n       4        -1416 \n       5        -1416 \nFixed bandwidth: 2382.777 AICc value: 4755.491 \n Iteration    Log-Likelihood:(With bandwidth:  2372.536 )\n=========================\n       0        -1958 \n       1        -1678 \n       2        -1528 \n       3        -1445 \n       4        -1411 \n       5        -1411 \nFixed bandwidth: 2372.536 AICc value: 4755.488 \n Iteration    Log-Likelihood:(With bandwidth:  2378.865 )\n=========================\n       0        -1960 \n       1        -1681 \n       2        -1532 \n       3        -1448 \n       4        -1414 \n       5        -1414 \nFixed bandwidth: 2378.865 AICc value: 4755.481 \n Iteration    Log-Likelihood:(With bandwidth:  2374.954 )\n=========================\n       0        -1959 \n       1        -1679 \n       2        -1530 \n       3        -1446 \n       4        -1412 \n       5        -1412 \nFixed bandwidth: 2374.954 AICc value: 4755.482 \n Iteration    Log-Likelihood:(With bandwidth:  2377.371 )\n=========================\n       0        -1959 \n       1        -1680 \n       2        -1531 \n       3        -1447 \n       4        -1413 \n       5        -1413 \nFixed bandwidth: 2377.371 AICc value: 4755.48 \n Iteration    Log-Likelihood:(With bandwidth:  2377.942 )\n=========================\n       0        -1960 \n       1        -1680 \n       2        -1531 \n       3        -1448 \n       4        -1414 \n       5        -1414 \nFixed bandwidth: 2377.942 AICc value: 4755.48 \n Iteration    Log-Likelihood:(With bandwidth:  2377.018 )\n=========================\n       0        -1959 \n       1        -1680 \n       2        -1531 \n       3        -1447 \n       4        -1413 \n       5        -1413 \nFixed bandwidth: 2377.018 AICc value: 4755.48 \n\n\nPress to toggle code\n        # since our data is projected, set longlat = FALSE\n\n\n\n\nPress to toggle code\nbw.fixed2\n\n\n[1] 2377.371\n\n\nThe result is 2377.371 km.\n\n\nPress to toggle code\ngwlr.fixed2 <- ggwr.basic(status ~  \n                 distance_to_tertiary_road +\n                 distance_to_city +\n                 distance_to_town +\n                 water_point_population +\n                 local_population_1km +\n                 usage_capacity +\n                 is_urban +\n                 water_source_clean,\n                 data = osun_wp_sp2,\n                 bw = bw.fixed2,\n                 family = \"binomial\",\n                 kernel = \"gaussian\",\n                 adaptive = FALSE,\n                 longlat = FALSE)\n\n\n Iteration    Log-Likelihood\n=========================\n       0        -1959 \n       1        -1680 \n       2        -1531 \n       3        -1447 \n       4        -1413 \n       5        -1413 \n\n\nPress to toggle code\ngwlr.fixed2\n\n\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n   Program starts at: 2022-12-17 23:34:15 \n   Call:\n   ggwr.basic(formula = status ~ distance_to_tertiary_road + distance_to_city + \n    distance_to_town + water_point_population + local_population_1km + \n    usage_capacity + is_urban + water_source_clean, data = osun_wp_sp2, \n    bw = bw.fixed2, family = \"binomial\", kernel = \"gaussian\", \n    adaptive = FALSE, longlat = FALSE)\n\n   Dependent (y) variable:  status\n   Independent variables:  distance_to_tertiary_road distance_to_city distance_to_town water_point_population local_population_1km usage_capacity is_urban water_source_clean\n   Number of data points: 4756\n   Used family: binomial\n   ***********************************************************************\n   *              Results of Generalized linear Regression               *\n   ***********************************************************************\n\nCall:\nNULL\n\nDeviance Residuals: \n     Min        1Q    Median        3Q       Max  \n-129.368    -1.750     1.074     1.742    34.126  \n\nCoefficients:\n                                           Estimate Std. Error z value Pr(>|z|)\nIntercept                                 3.540e-01  1.055e-01   3.354 0.000796\ndistance_to_tertiary_road                 1.001e-04  2.040e-05   4.910 9.13e-07\ndistance_to_city                         -1.764e-05  3.391e-06  -5.202 1.97e-07\ndistance_to_town                         -1.544e-05  2.825e-06  -5.466 4.60e-08\nwater_point_population                   -5.098e-04  4.476e-05 -11.390  < 2e-16\nlocal_population_1km                      3.452e-04  1.779e-05  19.407  < 2e-16\nusage_capacity1000                       -6.206e-01  6.966e-02  -8.908  < 2e-16\nis_urbanTRUE                             -2.667e-01  7.474e-02  -3.569 0.000358\nwater_source_cleanProtected Shallow Well  4.947e-01  8.496e-02   5.823 5.79e-09\nwater_source_cleanProtected Spring        1.279e+00  4.384e-01   2.917 0.003530\n                                            \nIntercept                                ***\ndistance_to_tertiary_road                ***\ndistance_to_city                         ***\ndistance_to_town                         ***\nwater_point_population                   ***\nlocal_population_1km                     ***\nusage_capacity1000                       ***\nis_urbanTRUE                             ***\nwater_source_cleanProtected Shallow Well ***\nwater_source_cleanProtected Spring       ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 6534.5  on 4755  degrees of freedom\nResidual deviance: 5688.9  on 4746  degrees of freedom\nAIC: 5708.9\n\nNumber of Fisher Scoring iterations: 5\n\n\n AICc:  5708.923\n Pseudo R-square value:  0.129406\n   ***********************************************************************\n   *          Results of Geographically Weighted Regression              *\n   ***********************************************************************\n\n   *********************Model calibration information*********************\n   Kernel function: gaussian \n   Fixed bandwidth: 2377.371 \n   Regression points: the same locations as observations are used.\n   Distance metric: A distance matrix is specified for this model calibration.\n\n   ************Summary of Generalized GWR coefficient estimates:**********\n                                                   Min.     1st Qu.      Median\n   Intercept                                -3.7021e+02 -4.3797e+00  3.5590e+00\n   distance_to_tertiary_road                -3.1622e-02 -4.5462e-04  9.1291e-05\n   distance_to_city                         -5.4555e-02 -6.5623e-04 -1.3507e-04\n   distance_to_town                         -8.6549e-03 -5.2754e-04 -1.6785e-04\n   water_point_population                   -2.9696e-02 -2.2705e-03 -1.2277e-03\n   local_population_1km                     -7.7730e-02  4.4281e-04  1.0548e-03\n   usage_capacity1000                       -5.5889e+01 -1.0347e+00 -4.1960e-01\n   is_urbanTRUE                             -7.3554e+02 -3.4675e+00 -1.6596e+00\n   water_source_cleanProtected.Shallow.Well -1.8842e+02 -4.7295e-01  6.2378e-01\n   water_source_cleanProtected.Spring       -1.3630e+03 -5.3436e+00  2.7714e+00\n                                                3rd Qu.      Max.\n   Intercept                                 1.3755e+01 2171.6373\n   distance_to_tertiary_road                 6.3011e-04    0.0237\n   distance_to_city                          1.5921e-04    0.0162\n   distance_to_town                          2.4490e-04    0.0179\n   water_point_population                    4.5879e-04    0.0765\n   local_population_1km                      1.8479e-03    0.0333\n   usage_capacity1000                        3.9113e-01    9.2449\n   is_urbanTRUE                              1.0554e+00  995.1840\n   water_source_cleanProtected.Shallow.Well  1.9564e+00   66.8914\n   water_source_cleanProtected.Spring        7.0805e+00  208.3749\n   ************************Diagnostic information*************************\n   Number of data points: 4756 \n   GW Deviance: 2815.659 \n   AIC : 4418.776 \n   AICc : 4744.213 \n   Pseudo R-square value:  0.5691072 \n\n   ***********************************************************************\n   Program stops at: 2022-12-17 23:34:44 \n\n\nAs observed from above, the AIC values dropped down from 5708.923 to 4418.776 which is still higher than the that of the first geographically weighted logistic regression with AIC at 4414.61."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#converting-sdf-into-sf-data.frame-1",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#converting-sdf-into-sf-data.frame-1",
    "title": "In-class Exercise 5",
    "section": "Converting SDF into sf data.frame",
    "text": "Converting SDF into sf data.frame\n\n\nPress to toggle code\ngwr.fixed2 <- as.data.frame(gwlr.fixed2$SDF)\n\n\nSince 'yhat' is probability, we need to create a new logical column called 'most' to label as 1 or 0 if the 'yhat' is greater or equal to 0.5.\n\n\nPress to toggle code\ngwr.fixed2 <- gwr.fixed2 %>% \n  mutate(most = ifelse(\n    gwr.fixed2$yhat >= 0.5, T, F))\n\n\nThe code chunk below creates the confusion matrix of the model.\n\n\nPress to toggle code\ngwr.fixed2$y <- as.factor(gwr.fixed2$y)\n\ngwr.fixed2$most <- as.factor(gwr.fixed2$most)\n\nCM2 <- confusionMatrix(data = gwr.fixed2$most, reference = gwr.fixed2$y)\n\nCM2\n\n\nConfusion Matrix and Statistics\n\n          Reference\nPrediction FALSE TRUE\n     FALSE  1833  268\n     TRUE    281 2374\n                                          \n               Accuracy : 0.8846          \n                 95% CI : (0.8751, 0.8935)\n    No Information Rate : 0.5555          \n    P-Value [Acc > NIR] : <2e-16          \n                                          \n                  Kappa : 0.7661          \n                                          \n Mcnemar's Test P-Value : 0.6085          \n                                          \n            Sensitivity : 0.8671          \n            Specificity : 0.8986          \n         Pos Pred Value : 0.8724          \n         Neg Pred Value : 0.8942          \n             Prevalence : 0.4445          \n         Detection Rate : 0.3854          \n   Detection Prevalence : 0.4418          \n      Balanced Accuracy : 0.8828          \n                                          \n       'Positive' Class : FALSE           \n                                          \n\n\nThe accuracy is 88.46%, the sensitivity is 86.71% and the specificity is 89.86%. While the accuracy increased by 0.09% and the sensitivity increased by 0.33%, the specificity decreased by 0.19%. The improvement is quite negligible, but there is more improvement here than the simple logistic model.\nThe code chunk below combines our water point data and model.\n\n\nPress to toggle code\ngwr_sf.fixed2 <- cbind(osun_wp_sf_selected, gwr.fixed2)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-coefficient-estimates-1",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-coefficient-estimates-1",
    "title": "In-class Exercise 5",
    "section": "Visualizing Coefficient Estimates",
    "text": "Visualizing Coefficient Estimates\nThe code chunk below creates an interactive point map of the probability.\n\n\nPress to toggle code\ntmap_mode(\"view\")\nprob_T2 <- tm_shape(osun) + \n  tm_polygons(alpha = 0.1) + \n  tm_shape(gwr_sf.fixed2) + \n  tm_dots(col = \"yhat\",\n          palette = \"RdPu\",\n          border.col = \"#704276\",\n          border.lwd = 1) +\n  tm_view(set.zoom.limits = c(8,14))\n\nprob_T2"
  }
]